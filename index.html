<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portfolio</title>
  <style>
@font-face {
  font-family: 'Monospace821Bold';
  src: url('assets/fonts/MONOSPACE821BOLDBT.TTF') format('truetype');
  font-weight: bold;
}
@font-face {
  font-family: 'Monospace821';
  src: url('assets/fonts/MONOSPACE821BT.TTF') format('truetype');
  font-weight: normal;
}
@import url('https://fonts.googleapis.com/css?family=Oswald:wght@400;600&display=swap');

body { margin: 0; overflow: hidden; }

/* Reticle */
#reticle {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  margin: -10px 0 0 -10px;
  border: 2px solid #fff;
  border-radius: 50%;
  pointer-events: none;
  z-index: 100;
  transition: all 0.2s ease;
  box-shadow: 0 0 10px rgba(255,255,255,0.5);
}

#reticle.hover {
  border-color: #22ff00;
  box-shadow: 0 0 20px rgba(34,255,0,0.8);
  transform: scale(1.3);
}

/* Menu */
#top-menu {
  display: none;
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: invert(100%) blur(5px);
  z-index: 9999;
  padding: 40px;
  box-sizing: border-box;
}

#menu-logo {
  position: absolute;
  top: 40px;
  right: 150px;
  width: 100px;    
  height: auto;
  cursor: pointer;
  transition: transform 0.3s ease, filter 0.3s ease;
}

#menu-logo img {
  width: 200px;
  height: auto;
}

#menu-pages {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}

.menu-btn {
  font-family: 'monospace821';
  font-weight: 900;
  font-size: 15em;
  background: none;
  color: #ffffff;
  cursor: pointer;
  border: none;
  text-align: left;
  text-decoration: underline;
}

.menu-btn:hover {
  color: rgb(34, 255, 0);
}

#menu-info {
  margin-top: 40px;
  font-family: 'monospace821';
  color: #fff;
  font-size: 1.5em;
}

/* Popup */
#popup {
  display: none;
  position: fixed;
  left: 5vw; top: 5vh;
  width: 90vw; height: 90vh;
  background: rgba(255,255,255,0.97);
  border: 2px solid #333;
  border-radius: 1px;
  color: #222;
  font-family: 'Monospace821';
  z-index: 10001;
  box-shadow: 0 8px 32px rgba(0,0,0,0.25);
  font-size: 1em;
  transition: opacity 0.2s;
  overflow: hidden;
}

#popup .close-btn {
  position: absolute;
  top: 18px; right: 28px;
  font-size: 2em;
  color: #ff0000;
  background: none;
  border: none;
  cursor: pointer;
  z-index: 11;
  transition: color 0.2s;
}

#popup .close-btn:hover { color: #222; }

#popup .popup-content-layout {
  display: flex;
  height: 100%;
  width: 100%;
}

#popup .popup-left {
  width: 30%; 
  padding: 24px 20px 24px 24px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  border-right: 1.5px solid #e0e0e0;
  overflow-y: auto; 
  position: relative;
  z-index: 1;
}

#popup .popup-left h2 {
  font-family: 'monospace821Bold';
}

#popup .popup-left p {
  pointer-events: auto;
}

#popup .popup-right {
  width: 70%;
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#popup .popup-images-scroll {
  flex: auto;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  -ms-overflow-style: none;
  scrollbar-width: none;
}

#popup .popup-images-scroll::-webkit-scrollbar { width: 0; height: 0; }

#popup .popup-images-scroll img,
#popup .popup-images-scroll video {
  display: block;
  width: 100%;
  height: auto;
  object-fit: contain;
  cursor: pointer;
}

#popup .image-row {
  display: flex;
  gap: 0px;
  width: 100%;
  align-items: stretch;
}

#popup .image-row img,
#popup .image-row video {
  flex: 1;
  height: 400px;
  object-fit: cover;
}

/* Fullscreen image modal */
#image-modal {
  display: none;
  position: fixed;
  z-index: 10002;
  left: 0; top: 0;
  width: 100vw; height: 100vh;
  background: rgba(0,0,0,0.85);
  align-items: center;
  justify-content: center;
  cursor: zoom-out;
}

#image-modal img {
  max-width: 90vw;
  max-height: 90vh;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  background: #fff;
}

#image-modal .modal-close-btn {
  position: absolute;
  top: 32px; right: 48px;
  font-size: 3em;
  color: #fff;
  background: none;
  border: none;
  cursor: pointer;
  z-index: 10003;
  text-shadow: 0 2px 8px #000;
}

#image-modal .modal-close-btn:hover { color: #FFD600; }

/* Click prompt */
#click-prompt {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-family: 'Monospace821Bold', monospace;
  font-size: 2em;
  color: #fff;
  background-color: #000;
  text-align: center;
  z-index: 500;
  pointer-events: none;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
}

/* Mobile Controls */
#mobile-controls {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 200px;
  z-index: 1000;
  pointer-events: none;
}

.mobile-joystick {
  position: absolute;
  width: 120px;
  height: 120px;
  bottom: 40px;
  pointer-events: auto;
}

#movement-joystick {
  left: 40px;
}

#look-joystick {
  right: 40px;
}

.joystick-base {
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.2);
  border: 3px solid rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  position: relative;
}

.joystick-stick {
  width: 50px;
  height: 50px;
  background: rgba(255, 255, 255, 0.7);
  border: 2px solid #fff;
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: all 0.1s ease;
}

#mobile-menu-btn {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 1001;
  font-family: 'Monospace821Bold', monospace;
  font-size: 2.5em;
  color: #fff;
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid #fff;
  padding: 10px 20px;
  cursor: pointer;
  display: none;
  pointer-events: auto;
}

#mobile-jump-btn {
  position: fixed;
  bottom: 180px;
  right: 40px;
  width: 80px;
  height: 80px;
  z-index: 1001;
  font-family: 'Monospace821Bold', monospace;
  font-size: 1.5em;
  color: #fff;
  background: rgba(255, 255, 255, 0.2);
  border: 3px solid rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  cursor: pointer;
  display: none;
  pointer-events: auto;
}

@media (max-width: 768px) {
  #mobile-controls {
    display: block;
  }
  
  #mobile-menu-btn,
  #mobile-jump-btn {
    display: block;
  }
  
  #click-prompt {
    display: none !important;
  }
  
  #reticle {
    display: none;
  }
  
  .menu-btn {
    font-size: 8em;
  }
  
  #menu-info {
    font-size: 1em;
  }
}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/gifler@0.1.0/gifler.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="reticle"></div>

<div id="click-prompt">|| CLICK_TO_START ||  ESC=MENU</div>

<div id="top-menu">
  <div id="menu-pages">
    <button class="menu-btn" data-url="index.html">HOME</button>
    <button class="menu-btn" data-url="about.html">ABOUT</button>
    <button class="menu-btn" data-url="gallery.html">GALLERY</button>
    <div id="menu-info">
      <div>// WASD=MOVE // MOUSE=LOOK_AROUND // ESC=MENU // CLICK=SELECT //</div>
    </div>
  </div>
  <div id="menu-logo">
    <a href="home.html">
      <img src="assets/haumlogofinal.svg" alt="Logo">
    </a>
  </div>
</div>

<div id="popup">
  <div id="popup-content"></div>
</div>

<div id="image-modal" onclick="PortfolioApp.closeImageModal(event)">
  <button class="modal-close-btn" onclick="PortfolioApp.closeImageModal(event)">&times;</button>
  <img id="modal-img" src="" alt="Popup Image">
</div>

<button id="mobile-menu-btn">â˜°</button>
<button id="mobile-jump-btn">JUMP</button>

<div id="mobile-controls">
  <div id="movement-joystick" class="mobile-joystick">
    <div class="joystick-base">
      <div class="joystick-stick"></div>
    </div>
  </div>
  <div id="look-joystick" class="mobile-joystick">
    <div class="joystick-base">
      <div class="joystick-stick"></div>
    </div>
  </div>
</div>

<script>
// ===== CONFIG MODULE =====
const CONFIG = {
  HOVER_DISTANCE: 60,
  CLICK_DISTANCE: 90,
  MOVEMENT_SPEED: 300,
  JUMP_FORCE: 250,
  MOUSE_SENSITIVITY: 0.002,
  
  gifUrls: [
    'assets/arach.gif', 'assets/baron.gif', 'assets/chomphead.gif', 'assets/dancingdino.gif',
    'assets/dragonmouth.gif', 'assets/elemental.gif', 'assets/greendragon.gif', 'assets/jackhammer.gif',
    'assets/legorun.gif', 'assets/orangedino.gif', 'assets/pinkydemon.gif', 'assets/shotgunblast.gif',
    'assets/skullfire.gif', 'assets/whitedragon.gif', 'assets/yellowdragon.gif'
  ]
};

// ===== INPUT MANAGER MODULE =====
const InputManager = {
  keys: {},
  pointerLocked: false,
  mobileMovement: { x: 0, z: 0 },
  mobileLook: { x: 0, y: 0 },
  mobileJump: false,
  
  init() {
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Escape') {
        e.preventDefault();
        return;
      }
      this.keys[e.code] = true;
    });
    
    document.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
    });
    
    if (!CONFIG.IS_MOBILE) {
      document.addEventListener('pointerlockchange', () => {
        const wasLocked = this.pointerLocked;
        this.pointerLocked = document.pointerLockElement === document.body;
        
        if (this.pointerLocked) {
          document.getElementById('click-prompt').style.display = 'none';
        }
        
        if (wasLocked && !this.pointerLocked && !PortfolioApp.menuOpen && !PortfolioApp.popupVisible) {
          PortfolioApp.openMenu();
        }
      });
      
      document.addEventListener('click', () => {
        if (!this.pointerLocked && !PortfolioApp.popupVisible && !PortfolioApp.menuOpen) {
          document.body.requestPointerLock();
        }
      });
    } else {
      this.initMobileControls();
    }
  },
  
  initMobileControls() {
    this.initJoystick('movement-joystick', (x, y) => {
      this.mobileMovement.x = x;
      this.mobileMovement.z = -y;
    });
    
    this.initJoystick('look-joystick', (x, y) => {
      this.mobileLook.x = x;
      this.mobileLook.y = y;
    });
    
    const jumpBtn = document.getElementById('mobile-jump-btn');
    jumpBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.mobileJump = true;
    });
    jumpBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.mobileJump = false;
    });
    
    const menuBtn = document.getElementById('mobile-menu-btn');
    menuBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      PortfolioApp.toggleMenu();
    });
  },
  
  initJoystick(id, callback) {
    const joystick = document.getElementById(id);
    const stick = joystick.querySelector('.joystick-stick');
    const base = joystick.querySelector('.joystick-base');
    
    let active = false;
    let startX = 0, startY = 0;
    
    const handleStart = (e) => {
      e.preventDefault();
      active = true;
      const rect = base.getBoundingClientRect();
      startX = rect.left + rect.width / 2;
      startY = rect.top + rect.height / 2;
    };
    
    const handleMove = (e) => {
      if (!active) return;
      e.preventDefault();
      
      const touch = e.touches ? e.touches[0] : e;
      const rect = base.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      let deltaX = touch.clientX - centerX;
      let deltaY = touch.clientY - centerY;
      
      const maxDistance = rect.width / 2 - 25;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      if (distance > maxDistance) {
        deltaX = (deltaX / distance) * maxDistance;
        deltaY = (deltaY / distance) * maxDistance;
      }
      
      stick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
      
      const normalizedX = deltaX / maxDistance;
      const normalizedY = deltaY / maxDistance;
      callback(normalizedX, normalizedY);
    };
    
    const handleEnd = (e) => {
      e.preventDefault();
      active = false;
      stick.style.transform = 'translate(-50%, -50%)';
      callback(0, 0);
    };
    
    joystick.addEventListener('touchstart', handleStart);
    joystick.addEventListener('touchmove', handleMove);
    joystick.addEventListener('touchend', handleEnd);
    joystick.addEventListener('touchcancel', handleEnd);
  },
  
  isKeyPressed(code) {
    return this.keys[code] || false;
  },
  
  getMovementInput() {
    if (CONFIG.IS_MOBILE) {
      return {
        x: this.mobileMovement.x,
        z: this.mobileMovement.z
      };
    } else {
      return {
        x: (this.isKeyPressed('KeyD') || this.isKeyPressed('ArrowRight') ? 1 : 0) - 
           (this.isKeyPressed('KeyA') || this.isKeyPressed('ArrowLeft') ? 1 : 0),
        z: (this.isKeyPressed('KeyS') || this.isKeyPressed('ArrowDown') ? 1 : 0) - 
           (this.isKeyPressed('KeyW') || this.isKeyPressed('ArrowUp') ? 1 : 0)
      };
    }
  },
  
  shouldJump() {
    if (CONFIG.IS_MOBILE) {
      const jump = this.mobileJump;
      if (jump) this.mobileJump = false;
      return jump;
    } else {
      return this.isKeyPressed('Space');
    }
  }
};

// ===== SCENE MANAGER MODULE =====
const SceneManager = {
  scene: null,
  camera: null,
  renderer: null,
  yaw: null,
  pitch: null,
  objects: [],
  boxes: [],
  videos: [],
  videoElements: {},
  gifAnimations: [],
  
  init() {
    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    this.pitch = new THREE.Object3D();
    this.pitch.add(this.camera);
    this.yaw = new THREE.Object3D();
    this.yaw.position.y = 20;
    this.yaw.add(this.pitch);
    this.yaw.rotation.y = 9.5;
    
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0xcc11cc);
    this.scene.fog = new THREE.Fog(0xff00ff, 0, 700);
    this.scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.5));
    this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(0, 300, 50);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.left = -200;
    dirLight.shadow.camera.right = 200;
    dirLight.shadow.camera.top = 400;
    dirLight.shadow.camera.bottom = -400;
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 500;
    this.scene.add(dirLight);
    this.scene.add(this.yaw);
    
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(this.renderer.domElement);
    
    window.addEventListener('resize', () => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    this.loadProjects();
  },
  
  createCheckeredTexture(size = 1024, squares = 32) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');
    const s = size / squares;
    for (let y = 0; y < squares; y++) {
      for (let x = 0; x < squares; x++) {
        ctx.fillStyle = (x + y) % 2 ? '#1976D2' : '#FFD600';
        ctx.fillRect(x * s, y * s, s, s);
      }
    }
    return new THREE.CanvasTexture(canvas);
  },
  
  createDeformedGeometry(geometry, deformAmount = 10) {
    const pos = geometry.attributes.position;
    const vertex = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
      vertex.fromBufferAttribute(pos, i);
      vertex.x += (Math.random() - 0.5) * deformAmount;
      vertex.y += (Math.random() - 0.5) * deformAmount;
      vertex.z += (Math.random() - 0.5) * deformAmount;
      pos.setXYZ(i, vertex.x, vertex.y, vertex.z);
    }
    return geometry;
  },
  
  createWall(width, height, segments, position, rotation, deformAmount = 10) {
    const geometry = this.createDeformedGeometry(
      new THREE.PlaneGeometry(width, height, segments[0], segments[1]),
      deformAmount
    );
    const texture = this.createCheckeredTexture();
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(2, 2);
    
    const wall = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }));
    wall.position.set(...position);
    if (rotation) wall.rotation.set(...rotation);
    wall.userData.type = 'floorOrWall';
    return wall;
  },
  
  extendRoom(newLength) {
    this.objects.forEach(obj => {
      if (obj.userData.type === 'floorOrWall') {
        this.scene.remove(obj);
      }
    });
    this.objects = this.objects.filter(obj => obj.userData.type !== 'floorOrWall');
    
    const floorGeo = this.createDeformedGeometry(
      new THREE.PlaneGeometry(200, newLength, 20, Math.max(2, Math.ceil(newLength / 10))),
      2
    );
    floorGeo.rotateX(-Math.PI / 2);
    const tex = this.createCheckeredTexture();
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2, Math.max(1, newLength / 50));
    const floor = new THREE.Mesh(
      floorGeo,
      new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide })
    );
    floor.position.set(0, 4, newLength / 2);
    floor.receiveShadow = true;
    floor.userData.type = 'floorOrWall';
    this.scene.add(floor);
    this.objects.push(floor);
    
    const walls = [
      this.createWall(newLength, 200, [20, 40], [-100, -1, newLength / 2], [0, Math.PI/2, -0.15]),
      this.createWall(newLength, 200, [20, 40], [90, 4, newLength / 2], [0, Math.PI/2, 0.15]),
      this.createWall(200, 200, [20, 40], [0, 4, newLength], [0.15, 0, 0]),
      this.createWall(200, 200, [20, 40], [0, 4, 0], [-0.15, 0, 0])
    ];
    walls.forEach(w => {
      this.scene.add(w);
      this.objects.push(w);
    });
  },
  
  loadProjects() {
    fetch('assets/projects.json')
      .then(res => res.json())
      .then(projects => {
        let maxZ = 0;
        const textureLoader = new THREE.TextureLoader();
        const rotationSpeeds = [];
        
        projects.forEach((project, idx) => {
          let material;
          const isVideo = project.type === 'video';
          
          if (isVideo) {
            const videoElem = document.createElement('video');
            videoElem.src = project.videoSrc;
            videoElem.muted = true;
            videoElem.loop = true;
            videoElem.playsInline = true;
            
            videoElem.play().catch(() => {
              document.body.addEventListener("click", () => {
                videoElem.play().catch(() => {});
              }, { once: true });
            });
            
            const videoTexture = new THREE.VideoTexture(videoElem);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.format = THREE.RGBFormat;
            
            this.videos.push(videoElem);
            this.videoElements[project.id] = videoElem;
            material = new THREE.MeshStandardMaterial({ map: videoTexture });
          } else {
            material = new THREE.MeshStandardMaterial({
              map: textureLoader.load(`assets/${project.thumbnail}`)
            });
          }
          
          let geometry;
          if (isVideo) {
            geometry = new THREE.BoxGeometry(project.width, project.height, project.depth);
          } else {
            geometry = new THREE.BoxGeometry(project.width, project.height, 0.5);
          }
          
          const box = new THREE.Mesh(geometry, material);
          box.position.set(project.x, project.y, project.z);
          box.castShadow = true;
          box.receiveShadow = true;
          box.userData.projectId = project.id;
          box.userData.projectData = project;
          
          this.scene.add(box);
          this.boxes.push(box);
          
          rotationSpeeds.push((Math.random() - 0.5) * 0.04);
          
          maxZ = Math.max(maxZ, project.z);
        });
        
        this.boxRotationSpeeds = rotationSpeeds;
        this.extendRoom(maxZ + 100);
        this.createGifPlanes(maxZ + 100);
      })
      .catch(err => console.error('Failed to load projects JSON', err));
  },
  
  createGifPlanes(roomLength) {
    const minDistance = 30;
    const rectWidth = 150;
    const rectCenterZ = roomLength / 2, rectCenterX = 0;
    const numPlanes = 100;
    const minY = 10, maxY = 80;
    
    for (let i = 0; i < numPlanes; i++) {
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(Math.random() * 15 + 10, Math.random() * 15 + 10),
        new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide })
      );
      
      let x, y, z, attempts = 0;
      do {
        x = rectCenterX + (Math.random() - 0.5) * rectWidth;
        z = rectCenterZ + (Math.random() - 0.5) * roomLength;
        y = Math.random() * (maxY - minY) + minY;
        attempts++;
        
        const tooClose = this.boxes.some(box => {
          const dist = Math.sqrt((x - box.position.x) ** 2 + (y - box.position.y) ** 2 + (z - box.position.z) ** 2);
          return dist < minDistance;
        });
        
        if (!tooClose || attempts > 100) break;
      } while (true);
      
      plane.position.set(x, y, z);
      plane.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      this.scene.add(plane);
      
      const gifUrl = CONFIG.gifUrls[i % CONFIG.gifUrls.length];
      try {
        gifler(gifUrl).get((anim) => {
          const canvas = document.createElement('canvas');
          canvas.width = anim.width;
          canvas.height = anim.height;
          const texture = new THREE.CanvasTexture(canvas);
          plane.material.map = texture;
          plane.material.transparent = true;
          plane.material.alphaTest = 0.1;
          plane.material.needsUpdate = true;
          
          this.gifAnimations.push(anim);
          anim.animateInCanvas(canvas);
          
          let animationRunning = true;
          function updateTexture() {
            if (animationRunning && !PortfolioApp.menuOpen) {
              texture.needsUpdate = true;
            }
            requestAnimationFrame(updateTexture);
          }
          updateTexture();
          
          anim.stop = () => { animationRunning = false; };
          anim.play = () => { animationRunning = true; };
        }).catch(() => {
          plane.material.color.set(0xff00ff);
          plane.material.needsUpdate = true;
        });
      } catch (e) {
        plane.material.color.set(0xffffff);
        plane.material.needsUpdate = true;
      }
    }
  },
  
  pauseAllAnimations() {
    this.videos.forEach(video => {
      video.userData = video.userData || {};
      video.userData.wasPlaying = !video.paused;
      if (!video.paused) video.pause();
    });
    
    this.gifAnimations.forEach(anim => {
      if (anim.stop) anim.stop();
    });
  },
  
  resumeAllAnimations() {
    this.videos.forEach(video => {
      if (video.userData && video.userData.wasPlaying) {
        video.play().catch(() => {});
        video.userData.wasPlaying = false;
      }
    });
    
    this.gifAnimations.forEach(anim => {
      if (anim.play) anim.play();
    });
  }
};

// ===== PHYSICS MANAGER MODULE =====
const PhysicsManager = {
  velocity: new THREE.Vector3(),
  direction: new THREE.Vector3(),
  canJump: false,
  raycaster: new THREE.Raycaster(),
  
  update(delta) {
    const yaw = SceneManager.yaw;
    
    yaw.position.x = Math.max(-95, Math.min(85, yaw.position.x));
    const roomEndZ = Math.max(...SceneManager.objects.map(o => o.position.z)) - 5;
    yaw.position.z = Math.max(5, Math.min(roomEndZ, yaw.position.z));
    
    this.raycaster.ray.origin.copy(yaw.position);
    this.raycaster.ray.origin.y += 1;
    this.raycaster.ray.direction.set(0, -1, 0);
    const hits = this.raycaster.intersectObjects(SceneManager.objects, false);
    const onGround = hits.length > 0 && hits[0].distance < 2;
    
    this.velocity.x -= this.velocity.x * 8 * delta;
    this.velocity.z -= this.velocity.z * 8 * delta;
    this.velocity.y -= 5 * 200 * delta;
    
    const input = InputManager.getMovementInput();
    this.direction.set(input.x, 0, input.z).normalize();
    
    if (this.direction.z) this.velocity.z -= this.direction.z * CONFIG.MOVEMENT_SPEED * delta;
    if (this.direction.x) this.velocity.x += this.direction.x * CONFIG.MOVEMENT_SPEED * delta;
    
    if (!onGround) {
      const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);
      const maxAir = 300, airAccel = 400;
      if (this.direction.x && speed < maxAir) this.velocity.x += this.direction.x * airAccel * delta;
      if (this.direction.z && speed < maxAir) this.velocity.z -= this.direction.z * airAccel * delta;
    }
    
    if (onGround) {
      this.velocity.y = Math.max(0, this.velocity.y);
      this.canJump = true;
    }
    
    if (InputManager.shouldJump() && this.canJump) {
      this.velocity.y += CONFIG.JUMP_FORCE;
      this.canJump = false;
    }
    
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yaw.quaternion).setY(0).normalize();
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(yaw.quaternion).setY(0).normalize();
    yaw.position.addScaledVector(forward, this.velocity.z * delta);
    yaw.position.addScaledVector(right, this.velocity.x * delta);
    yaw.position.y += this.velocity.y * delta;
    
    if (yaw.position.y < 20) {
      this.velocity.y = 0;
      yaw.position.y = 20;
      this.canJump = true;
    }
  }
};

// ===== INTERACTION MANAGER MODULE =====
const InteractionManager = {
  raycaster: new THREE.Raycaster(),
  reticle: null,
  hoveredBox: null,
  
  init() {
    this.reticle = document.getElementById('reticle');
    
    if (!CONFIG.IS_MOBILE) {
      document.addEventListener('mousemove', (e) => {
        if (InputManager.pointerLocked && !PortfolioApp.popupVisible && !PortfolioApp.menuOpen) {
          SceneManager.yaw.rotation.y -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
          SceneManager.pitch.rotation.x = Math.max(
            -Math.PI/2, 
            Math.min(Math.PI/2, SceneManager.pitch.rotation.x - e.movementY * CONFIG.MOUSE_SENSITIVITY)
          );
        }
      });
      
      document.addEventListener('click', (e) => {
        if (PortfolioApp.popupVisible) {
          const popup = document.getElementById('popup');
          const rect = popup.getBoundingClientRect();
          const clickedInside = e.clientX >= rect.left && e.clientX <= rect.right && 
                               e.clientY >= rect.top && e.clientY <= rect.bottom;
          
          if (!clickedInside) {
            PortfolioApp.hidePopup();
          }
          return;
        }
        
        if (!InputManager.pointerLocked || PortfolioApp.menuOpen) return;
        
        if (this.hoveredBox) {
          const cameraPos = new THREE.Vector3();
          SceneManager.camera.getWorldPosition(cameraPos);
          const dist = cameraPos.distanceTo(this.hoveredBox.position);
          
          if (dist <= CONFIG.CLICK_DISTANCE) {
            PortfolioApp.showPopup(this.hoveredBox.userData.projectData);
          }
        }
      });
    } else {
      document.addEventListener('touchstart', (e) => {
        if (PortfolioApp.popupVisible) {
          const popup = document.getElementById('popup');
          const rect = popup.getBoundingClientRect();
          const touch = e.touches[0];
          const clickedInside = touch.clientX >= rect.left && touch.clientX <= rect.right && 
                               touch.clientY >= rect.top && touch.clientY <= rect.bottom;
          
          if (!clickedInside) {
            PortfolioApp.hidePopup();
          }
          return;
        }
        
        if (PortfolioApp.menuOpen) return;
        
        if (this.hoveredBox) {
          const cameraPos = new THREE.Vector3();
          SceneManager.camera.getWorldPosition(cameraPos);
          const dist = cameraPos.distanceTo(this.hoveredBox.position);
          
          if (dist <= CONFIG.CLICK_DISTANCE) {
            PortfolioApp.showPopup(this.hoveredBox.userData.projectData);
          }
        }
      });
    }
  },
  
  update() {
    if (CONFIG.IS_MOBILE) {
      SceneManager.yaw.rotation.y -= InputManager.mobileLook.x * 0.05;
      SceneManager.pitch.rotation.x = Math.max(
        -Math.PI/2,
        Math.min(Math.PI/2, SceneManager.pitch.rotation.x - InputManager.mobileLook.y * 0.05)
      );
    }
    
    if ((!CONFIG.IS_MOBILE && !InputManager.pointerLocked) || PortfolioApp.popupVisible || PortfolioApp.menuOpen) {
      this.reticle.classList.remove('hover');
      this.hoveredBox = null;
      return;
    }
    
    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), SceneManager.camera);
    const intersects = this.raycaster.intersectObjects(SceneManager.boxes);
    
    if (intersects.length > 0) {
      const obj = intersects[0].object;
      const cameraPos = new THREE.Vector3();
      SceneManager.camera.getWorldPosition(cameraPos);
      const dist = cameraPos.distanceTo(obj.position);
      
      if (dist <= CONFIG.HOVER_DISTANCE) {
        this.reticle.classList.add('hover');
        this.hoveredBox = obj;
      } else {
        this.reticle.classList.remove('hover');
        this.hoveredBox = null;
      }
    } else {
      this.reticle.classList.remove('hover');
      this.hoveredBox = null;
    }
  }
};

// ===== POPUP MANAGER MODULE =====
const PopupManager = {
  generateHTML(project) {
    const mediaContent = project.media.map(m =>
      m.type === "video"
        ? `<video src="${m.src}" controls playsinline style="width:100%;height:auto;object-fit:contain;"></video>`
        : `<img src="${m.src}" alt="${project.title}" onclick="PortfolioApp.openImageModal(this)" style="width:100%;height:auto;object-fit:contain;display:block;">`
    ).join('');
    
    return `
      <div class="popup-content-layout">
        <div class="popup-left">
          <h2>${project.title}</h2>
          <p>${project.description}</p>
        </div>
        <div class="popup-right">
          <div class="popup-images-scroll">
            ${mediaContent}
          </div>
        </div>
      </div>
    `;
  },
  
  layoutMedia(root) {
    const scrollContainer = root.querySelector('.popup-images-scroll');
    if (!scrollContainer) return;
    
    const mediaElems = Array.from(scrollContainer.querySelectorAll('img, video'));
    if (mediaElems.length === 0) return;
    
    const promises = mediaElems.map(elem => new Promise(resolve => {
      if (elem.tagName === 'IMG') {
        if (elem.complete && elem.naturalWidth) {
          resolve({ elem, w: elem.naturalWidth, h: elem.naturalHeight });
        } else {
          const onLoad = () => {
            elem.removeEventListener('load', onLoad);
            resolve({ elem, w: elem.naturalWidth, h: elem.naturalHeight });
          };
          elem.addEventListener('load', onLoad);
        }
      } else {
        if (elem.readyState >= 1 && elem.videoWidth) {
          resolve({ elem, w: elem.videoWidth, h: elem.videoHeight });
        } else {
          const onMeta = () => {
            elem.removeEventListener('loadedmetadata', onMeta);
            resolve({ elem, w: elem.videoWidth, h: elem.videoHeight });
          };
          elem.addEventListener('loadedmetadata', onMeta);
        }
      }
    }));
    
    Promise.all(promises).then(results => {
      scrollContainer.innerHTML = '';
      let pendingRow = null;
      
      results.forEach(({ elem, w, h }) => {
        elem.style.maxWidth = '100%';
        elem.style.display = 'block';
        elem.style.height = 'auto';
        elem.style.objectFit = 'contain';
        
        const isPortrait = h > w;
        
        if (isPortrait) {
          if (!pendingRow) {
            pendingRow = document.createElement('div');
            pendingRow.className = 'image-row';
          }
          pendingRow.appendChild(elem);
          if (pendingRow.children.length === 2) {
            scrollContainer.appendChild(pendingRow);
            pendingRow = null;
          }
        } else {
          if (pendingRow) {
            scrollContainer.appendChild(pendingRow);
            pendingRow = null;
          }
          scrollContainer.appendChild(elem);
        }
      });
      
      if (pendingRow) {
        const spacer = document.createElement('div');
        spacer.style.flex = '1';
        pendingRow.appendChild(spacer);
        scrollContainer.appendChild(pendingRow);
      }
    }).catch(e => {
      console.warn('Error in layout popup media:', e);
    });
  }
};

// ===== MAIN APP MODULE =====
const PortfolioApp = {
  menuOpen: false,
  popupVisible: false,
  animationId: null,
  prevTime: performance.now(),
  
  init() {
    InputManager.init();
    SceneManager.init();
    InteractionManager.init();
    
    document.querySelectorAll('.menu-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const url = e.target.dataset.url;
        if (url) window.location.href = url;
      });
    });
    
    document.getElementById('top-menu').addEventListener('click', (e) => {
      if (e.target.id === 'top-menu' || e.target.id === 'menu-info') {
        this.closeMenu();
      }
    });
    
    this.animate();
  },
  
  toggleMenu() {
    this.menuOpen = !this.menuOpen;
    const menu = document.getElementById('top-menu');
    menu.style.display = this.menuOpen ? 'flex' : 'none';
    
    if (this.menuOpen) {
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
      SceneManager.pauseAllAnimations();
    } else {
      SceneManager.resumeAllAnimations();
      document.body.requestPointerLock();
    }
  },
  
  openMenu() {
    if (this.menuOpen) return;
    this.menuOpen = true;
    const menu = document.getElementById('top-menu');
    menu.style.display = 'flex';
    SceneManager.pauseAllAnimations();
  },
  
  closeMenu() {
    if (!this.menuOpen) return;
    this.menuOpen = false;
    const menu = document.getElementById('top-menu');
    menu.style.display = 'none';
    SceneManager.resumeAllAnimations();
    document.body.requestPointerLock();
  },
  
  showPopup(project) {
    const popup = document.getElementById('popup');
    const popupContent = document.getElementById('popup-content');
    const html = PopupManager.generateHTML(project);
    popupContent.innerHTML = html;
    requestAnimationFrame(() => PopupManager.layoutMedia(popupContent));
    popup.style.display = 'flex';
    popup.style.opacity = '1';
    this.popupVisible = true;
    
    if (document.pointerLockElement) {
      document.exitPointerLock();
    }
  },
  
  hidePopup() {
    const popup = document.getElementById('popup');
    popup.style.display = 'none';
    popup.style.opacity = '0';
    this.popupVisible = false;
    
    if (!this.menuOpen) {
      document.body.requestPointerLock();
    }
  },
  
  openImageModal(imgElem) {
    event.stopPropagation();
    document.getElementById('modal-img').src = imgElem.src;
    document.getElementById('image-modal').style.display = 'flex';
  },
  
  closeImageModal(event) {
    if (event.target.id === 'image-modal' || event.target.className === 'modal-close-btn') {
      document.getElementById('image-modal').style.display = 'none';
      document.getElementById('modal-img').src = '';
    }
  },
  
  animate() {
    this.animationId = requestAnimationFrame(() => this.animate());
    
    const time = performance.now();
    const delta = (time - this.prevTime) / 1000;
    this.prevTime = time;
    
    if (!this.menuOpen) {
      PhysicsManager.update(delta);
      InteractionManager.update();
      
      SceneManager.boxes.forEach((box, i) => {
        if (SceneManager.boxRotationSpeeds && SceneManager.boxRotationSpeeds[i] !== undefined) {
          box.rotation.y += SceneManager.boxRotationSpeeds[i];
        }
      });
    }
    
    SceneManager.renderer.render(SceneManager.scene, SceneManager.camera);
  }
};

// Initialize the app
PortfolioApp.init();
</script>
</body>
</html>
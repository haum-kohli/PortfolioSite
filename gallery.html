<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1" />
  <title>Gallery</title>
  <style>
  @font-face {
    font-family: 'MacklinSansBold';
    src: url('assets/fonts/MacklinSans-Bold.ttf') format('truetype');
    font-weight: bold;
  }
  @font-face {
    font-family: 'Monospace821Bold';
    src: url('assets/fonts/MONOSPACE821BOLDBT.TTF') format('truetype');
    font-weight: bold;
  }
  @font-face {
    font-family: 'Monospace821';
    src: url('assets/fonts/MONOSPACE821BT.TTF') format('truetype');
    font-weight: normal;
  }

  body { 
    margin: 0; 
    overflow: hidden;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  #loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #0500FF;
    z-index: 99999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Monospace821Bold', monospace;
    color: #fff;
    transition: opacity 0.5s ease;
  }

  #loading-screen.fade-out {
    opacity: 0;
    pointer-events: none;
  }

  .loading-text {
    font-size: 3em;
    margin-bottom: 40px;
  }

  .loading-bar-container {
    width: 60%;
    max-width: 500px;
    height: 30px;
    border: 3px solid #fff;
    position: relative;
    overflow: hidden;
  }

  .loading-bar {
    height: 100%;
    background: #fff;
    width: 0%;
    transition: width 0.3s ease;
  }

  .loading-percentage {
    font-size: 2em;
    margin-top: 20px;
  }

  #reticle {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid #fff;
    border-radius: 50%;
    pointer-events: none;
    z-index: 100;
    transition: all 0.2s ease;
    box-shadow: 0 0 10px rgba(255,255,255,0.5);
  }

  #reticle.hover {
    border-color: #0500FF;
    box-shadow: 0 0 20px rgba(5,0,255,0.8);
    transform: scale(1.3);
  }

  #top-menu {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(5, 0, 255, 0.85);
    backdrop-filter: invert(100%) blur(5px);
    z-index: 9999;
    padding: 40px;
    box-sizing: border-box;
    overflow: hidden;
    align-items: left;
    justify-content: left;
    flex-direction: column;
  }

  #menu-logo {
    width: 150px;
    height: auto;
    margin-bottom: 40px;
    cursor: pointer;
  }

  #menu-logo img {
    width: 100%;
    height: auto;
  }

  #menu-pages {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }

  .menu-btn {
    font-family: 'monospace821';
    font-weight: 900;
    font-size: 8em;
    background: none;
    color: #ffffff;
    cursor: pointer;
    border: none;
    text-align: left;
    text-decoration: underline;
    padding: 5px 0;
    transition: color 0.2s;
    line-height: 1;
  }

  .menu-btn:hover {
    color: #FF0000;
  }

  #popup {
  display: none;
  position: fixed;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.95);
  z-index: 10001;
  justify-content: center;
  align-items: center;
}

#popup-close-btn {
  position: absolute;
  top: 18px;
  right: 28px;
  font-size: 2em;
  color: #ff0000;
  background: none;
  border: none;
  cursor: pointer;
  z-index: 10003;
  transition: color 0.2s;
  font-family: 'Monospace821Bold', monospace;
  line-height: 1;
}

#popup-close-btn:hover { 
  color: #222; 
}

#popup-content {
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

.popup-images-scroll {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
  padding: 60px 20px 20px 20px;
  box-sizing: border-box;
}

  .popup-images-scroll img {
    width: 100%;
    height: auto;
    display: block;
    margin-bottom: 10px;
  }

  .popup-images-scroll video {
    width: 100%;
    height: auto;
    display: block;
    margin-bottom: 10px;
  }

  .popup-images-scroll iframe {
    width: 100%;
    aspect-ratio: 16/9;
    display: block;
    margin-bottom: 10px;
    border: none;
  }

  @media (min-width: 1025px) {
    .popup-images-scroll {
      align-items: center;
      justify-content: center;
      padding: 60px 40px 40px 40px;
    }
    
    .popup-images-scroll img {
      max-width: 90vw;
      max-height: 90vh;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    .popup-images-scroll video {
      max-width: 90vw;
      max-height: 90vh;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    .popup-images-scroll iframe {
      max-width: 90vw;
      max-height: 90vh;
      width: 80vw;
      aspect-ratio: 16/9;
    }
  }

  #click-prompt {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Monospace821Bold', monospace;
    font-size: 2em;
    color: #fff;
    background-color: #0500FF;
    text-align: center;
    z-index: 500;
    pointer-events: none;
    padding: 20px;
  }

  #mobile-controls {
    display: none;
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 200px;
    z-index: 1000;
    pointer-events: none;
  }

  .mobile-joystick {
    position: absolute;
    width: 120px;
    height: 120px;
    bottom: 40px;
    pointer-events: auto;
    left: 40px;
  }

  .joystick-base {
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.2);
    border: 3px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    position: relative;
    image-rendering: pixelated;
  }

  .joystick-stick {
    width: 50px;
    height: 50px;
    background: rgba(255, 255, 255, 0.7);
    border: 2px solid #fff;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    transition: none;
    image-rendering: pixelated;
  }

  #shotgun-gif {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 800px;
    height: auto;
    max-height: 1500px;
    z-index: 999;
    pointer-events: none;
    image-rendering: pixelated;
  }

  #mobile-menu-btn {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 1001;
    font-family: 'Monospace821Bold', monospace;
    font-size: 2em;
    color: #fff;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid #fff;
    padding: 8px 16px;
    cursor: pointer;
    display: none;
    pointer-events: auto;
    width: 50px;
    height: 50px;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
  }

#mobile-menu-close {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 10000;
  font-family: 'Monospace821Bold', monospace;
  font-size: 2em;
  color: #fff;
  background: none;
  border: none;
  cursor: pointer;
  display: none;
  pointer-events: auto;
  width: 60px;
  height: 60px;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

  @media (max-width: 1024px) {
    #mobile-controls {
      display: block;
    }
    
    #mobile-menu-btn {
      display: flex;
    }
    
    #click-prompt {
      display: none !important;
    }
    
    .menu-btn {
      font-size: 10vw;
      width: 100%;
    }
    
    #menu-logo {
      width: 100px;
      margin-bottom: 30px;
    }
    
    #menu-random-gif {
      display: block;
      margin-top: 30px;
      width: 70%;
      max-width: 300px;
      height: auto;
      border: 3px solid #fff;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
    }
    
    .loading-text {
      font-size: 2em;
    }
    
    .loading-bar-container {
      width: 80%;
    }
  }

  @media (min-width: 1025px) {
    #menu-logo {
      position: absolute;
      top: 40px;
      right: 40px;
      width: 150px;
      margin-bottom: 0;
    }
    
    #menu-pages {
      position: absolute;
      top: 40px;
      left: 40px;
    }
    
    .menu-btn {
      font-size: 12em;
    }
    
    #menu-random-gif {
      display: none;
    }
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/gifler@0.1.0/gifler.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="loading-screen">
  <div class="loading-text">|| LOADING ||</div>
  <div class="loading-bar-container">
    <div class="loading-bar" id="loading-bar"></div>
  </div>
  <div class="loading-percentage" id="loading-percentage">0%</div>
</div>

<div id="reticle"></div>
<div id="click-prompt">|| CLICK_TO_START || ESC=MENU</div>

<div id="top-menu" onclick="GalleryApp.handleMenuClick(event)">
  <button id="mobile-menu-close" onclick="GalleryApp.closeMenu()">&times;</button>
  <div id="menu-logo">
    <a href="index.html">
      <img src="assets/haumlogofinal.svg" alt="Logo">
    </a>
  </div>
  <div id="menu-pages">
    <button class="menu-btn" data-url="home.html">HOME</button>
    <button class="menu-btn" data-url="gallery.html">GALLERY</button>
    <button class="menu-btn" data-url="about.html">ABOUT</button>
  </div>
  <img id="menu-random-gif" src="" alt="Random GIF" style="display: none;">
</div>

<div id="popup">
  <button id="popup-close-btn" onclick="GalleryApp.hidePopup()">&times;</button>
  <div id="popup-content"></div>
</div>

<button id="mobile-menu-btn">+</button>
<img id="shotgun-gif" src="assets/POVSHOTGUN_static.png" alt="Shotgun">

<div id="mobile-controls">
  <div class="mobile-joystick">
    <div class="joystick-base">
      <div class="joystick-stick"></div>
    </div>
  </div>
</div>

<script>
const IS_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 1024;

const CONFIG = {
  IS_MOBILE,
  HOVER_DISTANCE: 160,
  CLICK_DISTANCE: 200,
  MOVEMENT_SPEED: 150,
  MOBILE_MOVEMENT_SPEED: 300,
  JUMP_FORCE: 350,
  MOUSE_SENSITIVITY: 0.002,
  MOBILE_LOOK_SENSITIVITY: 0.010,
  FOG_DISTANCE: IS_MOBILE ? 400 : 700,
  
  gifUrls: [
    'assets/gifs/arach.gif', 'assets/gifs/baron.gif', 'assets/gifs/chomphead.gif', 
    'assets/gifs/dancingdino.gif', 'assets/gifs/dragonmouth.gif', 'assets/gifs/elemental.gif', 
    'assets/gifs/greendragon.gif', 'assets/gifs/jackhammer.gif', 'assets/gifs/legorun.gif', 
    'assets/gifs/orangedino.gif', 'assets/gifs/pinkydemon.gif', 'assets/gifs/shotgunblast.gif',
    'assets/gifs/skullfire.gif', 'assets/gifs/whitedragon.gif', 'assets/gifs/yellowdragon.gif'
  ],
  
  mobileCategories: [
    { title: 'PHOTO', x: -40, y: 20, z: 120, category: 'photo' },
    { title: 'POSTERS', x: 40, y: 20, z: 120, category: 'posters' },
    { title: 'MISC DESIGN', x: -40, y: 20, z: 220, category: 'misc' },
    { title: 'VIDEO/MOTION', x: 40, y: 20, z: 220, category: 'video' }
  ]
};

const LoadingManager = {
  totalAssets: 0,
  loadedAssets: 0,
  isLoading: true,
  displayedPercentage: 0,
  targetPercentage: 0,
  smoothingInterval: null,
  timeoutId: null,
  
  init() {
    this.loadingScreen = document.getElementById('loading-screen');
    this.loadingBar = document.getElementById('loading-bar');
    this.loadingPercentage = document.getElementById('loading-percentage');
    this.startSmoothProgress();
    
    this.timeoutId = setTimeout(() => {
      console.warn('Loading timeout - forcing completion');
      this.forceComplete();
    }, 15000);
  },
  
  startSmoothProgress() {
    this.smoothingInterval = setInterval(() => {
      if (this.displayedPercentage < this.targetPercentage) {
        this.displayedPercentage = Math.min(
          this.targetPercentage,
          this.displayedPercentage + Math.max(1, (this.targetPercentage - this.displayedPercentage) * 0.1)
        );
        this.loadingBar.style.width = Math.round(this.displayedPercentage) + '%';
        this.loadingPercentage.textContent = Math.round(this.displayedPercentage) + '%';
        
        if (this.displayedPercentage >= 100) {
          clearInterval(this.smoothingInterval);
          setTimeout(() => this.complete(), 500);
        }
      }
    }, 50);
  },
  
  setTotal(total) {
    this.totalAssets = Math.max(1, total);
  },
  
  increment() {
    this.loadedAssets++;
    const actualPercentage = Math.min(100, (this.loadedAssets / this.totalAssets) * 100);
    this.targetPercentage = actualPercentage;
    
    if (this.loadedAssets >= this.totalAssets) {
      this.targetPercentage = 100;
    }
  },
  
  forceComplete() {
    this.targetPercentage = 100;
    this.displayedPercentage = 100;
    this.loadingBar.style.width = '100%';
    this.loadingPercentage.textContent = '100%';
    setTimeout(() => this.complete(), 500);
  },
  
  complete() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (this.smoothingInterval) {
      clearInterval(this.smoothingInterval);
      this.smoothingInterval = null;
    }
    this.isLoading = false;
    this.loadingScreen.classList.add('fade-out');
    setTimeout(() => this.loadingScreen.style.display = 'none', 500);
  }
};

const ShotgunGif = {
  imgElement: null,
  isPlaying: false,
  staticFrameUrl: 'assets/POVSHOTGUN_static.png',
  animatedUrl: 'assets/POVSHOTGUN.gif',
  
  init() {
    this.imgElement = document.getElementById('shotgun-gif');
    this.imgElement.src = this.staticFrameUrl;
  },
  
  play() {
    if (this.isPlaying || !this.imgElement) return;
    this.isPlaying = true;
    this.imgElement.src = this.animatedUrl + '?' + Math.random();
    setTimeout(() => {
      this.imgElement.src = this.staticFrameUrl;
      this.isPlaying = false;
    }, 1500);
  }
};

const InputManager = {
  keys: {},
  pointerLocked: false,
  mobileMovement: { x: 0, z: 0 },
  mobileLookDelta: { x: 0, y: 0 },
  activeTouches: new Map(),
  joystickTouchId: null,
  
  init() {
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Escape') {
        e.preventDefault();
        if (GalleryApp.popupVisible) {
          GalleryApp.hidePopup();
        }
        return;
      }
      this.keys[e.code] = true;
    });
    
    document.addEventListener('keyup', (e) => this.keys[e.code] = false);
    
    if (!CONFIG.IS_MOBILE) {
      this.initDesktopControls();
    } else {
      this.initMobileControls();
      document.getElementById('click-prompt').style.display = 'none';
    }
  },
  
  initDesktopControls() {
    document.addEventListener('pointerlockchange', () => {
      const wasLocked = this.pointerLocked;
      this.pointerLocked = document.pointerLockElement === document.body;
      
      if (this.pointerLocked) {
        document.getElementById('click-prompt').style.display = 'none';
      }
      
      if (wasLocked && !this.pointerLocked && !GalleryApp.menuOpen && !GalleryApp.popupVisible && !GalleryApp.popupJustClosed) {
        GalleryApp.openMenu();
      }
    });
    
    document.addEventListener('click', () => {
      if (!this.pointerLocked && !GalleryApp.popupVisible && !GalleryApp.menuOpen && !LoadingManager.isLoading) {
        document.body.requestPointerLock();
      }
    });
  },
  
  initMobileControls() {
    this.initJoystick();
    
    document.addEventListener('touchstart', (e) => {
      Array.from(e.changedTouches).forEach(touch => {
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        const isOnJoystick = target && target.closest('.mobile-joystick');
        const isOnUI = target && (target.closest('#mobile-menu-btn') || target.closest('#popup') || target.closest('#top-menu'));
        
        if (isOnJoystick) {
          this.joystickTouchId = touch.identifier;
        }
        
        this.activeTouches.set(touch.identifier, {
          startX: touch.clientX,
          startY: touch.clientY,
          lastX: touch.clientX,
          lastY: touch.clientY,
          isJoystick: isOnJoystick,
          isUI: isOnUI,
          isCameraControl: !isOnJoystick && !isOnUI,
          hasMoved: false,
          totalDistance: 0
        });
      });
    });
    
    document.addEventListener('touchmove', (e) => {
      if (GalleryApp.popupVisible || GalleryApp.menuOpen) return;
      
      Array.from(e.changedTouches).forEach(touch => {
        const touchData = this.activeTouches.get(touch.identifier);
        if (!touchData || !touchData.isCameraControl) return;
        
        const deltaX = touch.clientX - touchData.lastX;
        const deltaY = touch.clientY - touchData.lastY;
        
        const moveDist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        touchData.totalDistance += moveDist;
        
        if (touchData.totalDistance > 10) {
          touchData.hasMoved = true;
        }
        
        this.mobileLookDelta.x = deltaX;
        this.mobileLookDelta.y = deltaY;
        
        touchData.lastX = touch.clientX;
        touchData.lastY = touch.clientY;
      });
    });
    
    document.addEventListener('touchend', (e) => {
      Array.from(e.changedTouches).forEach(touch => {
        const touchData = this.activeTouches.get(touch.identifier);
        
        if (touch.identifier === this.joystickTouchId) {
          this.joystickTouchId = null;
          const stick = document.querySelector('.joystick-stick');
          stick.style.transform = 'translate(-50%, -50%)';
          this.mobileMovement.x = 0;
          this.mobileMovement.z = 0;
        }
        
        if (touchData && touchData.isCameraControl && !touchData.hasMoved && touchData.totalDistance < 20) {
          ShotgunGif.play();
          
          if (!GalleryApp.popupVisible && !GalleryApp.menuOpen && InteractionManager.hoveredBox) {
            const cameraPos = new THREE.Vector3();
            SceneManager.camera.getWorldPosition(cameraPos);
            const dist = cameraPos.distanceTo(InteractionManager.hoveredBox.position);
            
            if (dist <= CONFIG.CLICK_DISTANCE) {
              GalleryApp.showPopup(InteractionManager.hoveredBox);
            }
          }
        }
        
        this.activeTouches.delete(touch.identifier);
      });
      
      if (!Array.from(this.activeTouches.values()).some(t => t.isCameraControl)) {
        this.mobileLookDelta.x = 0;
        this.mobileLookDelta.y = 0;
      }
    });
    
    document.getElementById('mobile-menu-btn').addEventListener('click', (e) => {
      e.preventDefault();
      GalleryApp.toggleMenu();
    });
  },
  
  initJoystick() {
    const joystick = document.querySelector('.mobile-joystick');
    const stick = joystick.querySelector('.joystick-stick');
    const base = joystick.querySelector('.joystick-base');
    
    const handleMove = (e) => {
      if (this.joystickTouchId === null) return;
      e.preventDefault();
      
      let touch = null;
      if (e.touches) {
        for (let i = 0; i < e.touches.length; i++) {
          if (e.touches[i].identifier === this.joystickTouchId) {
            touch = e.touches[i];
            break;
          }
        }
      }
      if (!touch) return;
      
      const rect = base.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      let deltaX = touch.clientX - centerX;
      let deltaY = touch.clientY - centerY;
      
      const maxDistance = rect.width / 2 - 25;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      if (distance > maxDistance) {
        deltaX = (deltaX / distance) * maxDistance;
        deltaY = (deltaY / distance) * maxDistance;
      }
      
      stick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
      this.mobileMovement.x = deltaX / maxDistance;
      this.mobileMovement.z = deltaY / maxDistance;
    };
    
    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (e.touches && e.touches.length > 0) {
        this.joystickTouchId = e.touches[0].identifier;
      }
    }, { passive: false });
    
    joystick.addEventListener('touchmove', handleMove, { passive: false });
  },
  
  getMovementInput() {
    if (CONFIG.IS_MOBILE) {
      return { x: this.mobileMovement.x, z: this.mobileMovement.z };
    }
    return {
      x: (this.keys.KeyD || this.keys.ArrowRight ? 1 : 0) - (this.keys.KeyA || this.keys.ArrowLeft ? 1 : 0),
      z: (this.keys.KeyS || this.keys.ArrowDown ? 1 : 0) - (this.keys.KeyW || this.keys.ArrowUp ? 1 : 0)
    };
  }
};

const SceneManager = {
  scene: null,
  camera: null,
  renderer: null,
  yaw: null,
  pitch: null,
  objects: [],
  boxes: [],
  videos: [],
  gifAnimations: [],
  
  init() {
    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    this.pitch = new THREE.Object3D();
    this.pitch.add(this.camera);
    this.yaw = new THREE.Object3D();
    this.yaw.position.y = 20;
    this.yaw.add(this.pitch);
    this.yaw.rotation.y = 9.5;
    
this.scene = new THREE.Scene();
const skyUrl = CONFIG.IS_MOBILE 
  ? 'https://images.unsplash.com/photo-1647730096483-284aad556e20?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=687'
  : 'https://images.pexels.com/photos/531756/pexels-photo-531756.jpeg';
const skyTexture = new THREE.TextureLoader().load(skyUrl);
this.scene.background = skyTexture;
this.scene.fog = new THREE.Fog(0x87CEEB, 50, CONFIG.FOG_DISTANCE);
    
    this.scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, CONFIG.IS_MOBILE ? 0.3 : 0.5));
    this.scene.add(new THREE.AmbientLight(0xffffff, CONFIG.IS_MOBILE ? 0.4 : 0.5));
    
    if (!CONFIG.IS_MOBILE) {
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(0, 300, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      this.scene.add(dirLight);
    }
    this.scene.add(this.yaw);
    
    this.renderer = new THREE.WebGLRenderer({ 
      antialias: false,
      powerPreference: CONFIG.IS_MOBILE ? "low-power" : "high-performance",
      precision: CONFIG.IS_MOBILE ? 'lowp' : 'highp'
    });
    this.renderer.setPixelRatio(CONFIG.IS_MOBILE ? 1 : window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    
    if (!CONFIG.IS_MOBILE) {
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    }
    
    document.body.appendChild(this.renderer.domElement);
    
    window.addEventListener('resize', () => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    });
  },
  
  createCheckeredTexture(size = 512, squares = 16) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');
    const s = size / squares;
    for (let y = 0; y < squares; y++) {
      for (let x = 0; x < squares; x++) {
        ctx.fillStyle = (x + y) % 2 ? '#1976D2' : '#FFD600';
        ctx.fillRect(x * s, y * s, s, s);
      }
    }
    const texture = new THREE.CanvasTexture(canvas);
    if (CONFIG.IS_MOBILE) {
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = false;
    }
    return texture;
  },
  
  createDeformedGeometry(geometry, deformAmount = 10) {
    const pos = geometry.attributes.position;
    const vertex = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
      vertex.fromBufferAttribute(pos, i);
      vertex.x += (Math.random() - 0.5) * deformAmount;
      vertex.y += (Math.random() - 0.5) * deformAmount;
      vertex.z += (Math.random() - 0.5) * deformAmount;
      pos.setXYZ(i, vertex.x, vertex.y, vertex.z);
    }
    return geometry;
  },
  
 createRoom() {
  const roomLength = CONFIG.IS_MOBILE ? 300 : 600;
    
    const floorGeo = this.createDeformedGeometry(
      new THREE.PlaneGeometry(200, roomLength, 20, Math.max(2, Math.ceil(roomLength / 10))),
      2
    );
    floorGeo.rotateX(-Math.PI / 2);
    const tex = this.createCheckeredTexture();
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2, Math.max(1, roomLength / 50));
    const floor = new THREE.Mesh(
      floorGeo,
      new THREE.MeshStandardMaterial({ 
        map: tex, 
        side: THREE.DoubleSide,
        metalness: 0,
        roughness: 1
      })
    );
    floor.position.set(0, 4, roomLength / 2);
    if (!CONFIG.IS_MOBILE) floor.receiveShadow = true;
    this.scene.add(floor);
    this.objects.push(floor);
    
    const wallGeometry = (w, h, seg) => this.createDeformedGeometry(
      new THREE.PlaneGeometry(w, h, seg[0], seg[1]), 10
    );
    const wallMaterial = (tex) => new THREE.MeshStandardMaterial({ 
      map: tex, 
      side: THREE.DoubleSide,
      metalness: 0,
      roughness: 1
    });
    
    const wallTex1 = this.createCheckeredTexture();
    wallTex1.wrapS = wallTex1.wrapT = THREE.RepeatWrapping;
    wallTex1.repeat.set(2, 2);
    
    const leftWall = new THREE.Mesh(wallGeometry(roomLength, 200, [20, 40]), wallMaterial(wallTex1));
    leftWall.position.set(-100, -1, roomLength / 2);
    leftWall.rotation.set(0, Math.PI/2, -0.15);
    this.scene.add(leftWall);
    this.objects.push(leftWall);
    
    const rightWall = new THREE.Mesh(wallGeometry(roomLength, 200, [20, 40]), wallMaterial(wallTex1.clone()));
    rightWall.position.set(90, 4, roomLength / 2);
    rightWall.rotation.set(0, Math.PI/2, 0.15);
    this.scene.add(rightWall);
    this.objects.push(rightWall);
    
    const backWall = new THREE.Mesh(wallGeometry(200, 200, [20, 40]), wallMaterial(wallTex1.clone()));
    backWall.position.set(0, 4, roomLength);
    backWall.rotation.set(0.15, 0, 0);
    this.scene.add(backWall);
    this.objects.push(backWall);
    
    const frontWall = new THREE.Mesh(wallGeometry(200, 200, [20, 40]), wallMaterial(wallTex1.clone()));
    frontWall.position.set(0, 4, 0);
    frontWall.rotation.set(-0.15, 0, 0);
    this.scene.add(frontWall);
    this.objects.push(frontWall);
  },
  
  loadGallery() {
    if (CONFIG.IS_MOBILE) {
      this.loadMobileCategories();
    } else {
      this.loadDesktopGallery();
    }
  },
  
  loadMobileCategories() {
    LoadingManager.setTotal(CONFIG.mobileCategories.length);
    
    const textureLoader = new THREE.TextureLoader();
    
    CONFIG.mobileCategories.forEach((cat, idx) => {
      let texturePath = '';
      
      if (cat.category === 'photo') {
        texturePath = 'assets/photo.webp';
      } else if (cat.category === 'posters') {
        texturePath = 'assets/posters.webp';
      } else if (cat.category === 'video') {
        texturePath = 'assets/video.webp';
      } else if (cat.category === 'misc') {
        texturePath = 'assets/misc.webp';
      }
      
      textureLoader.load(
        texturePath,
        (texture) => {
          const geometry = new THREE.BoxGeometry(30, 30, 30);
          const material = new THREE.MeshStandardMaterial({ 
            map: texture,
            metalness: 0,
            roughness: 1
          });
          
          const box = new THREE.Mesh(geometry, material);
          box.position.set(cat.x, cat.y, cat.z);
          
          box.userData.categoryData = cat;
          box.userData.isMobileCategory = true;
          
          this.scene.add(box);
          this.boxes.push(box);
          
          LoadingManager.increment();
        },
        undefined,
        (err) => {
          console.error('Failed to load texture:', texturePath, err);
          
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext('2d');
          
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, 512, 512);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 48px monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(cat.title, 256, 256);
          
          const texture = new THREE.CanvasTexture(canvas);
          const geometry = new THREE.BoxGeometry(30, 30, 30);
          const material = new THREE.MeshStandardMaterial({ 
            map: texture,
            metalness: 0,
            roughness: 1,
            color: 0x888888
          });
          
          const box = new THREE.Mesh(geometry, material);
          box.position.set(cat.x, cat.y, cat.z);
          
          box.userData.categoryData = cat;
          box.userData.isMobileCategory = true;
          
          this.scene.add(box);
          this.boxes.push(box);
          
          LoadingManager.increment();
        }
      );
    });
    
    this.createRoom();
  },
  
  loadDesktopGallery() {
    fetch('assets/gallery.json')
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch gallery.json');
        return res.json();
      })
      .then(items => {
        LoadingManager.setTotal(items.length);
        
        const rowSpacing = 60, leftX = -70, rightX = 70, ceilingYOffset = 90;
        const ceilingX = [-30, 30], ceilingZSpacing = 50;
        const maxDimension = 40;
        const zOffset = 50;
        let lastZ = 0;
        let globalIndex = 0, rowIndex = 0, ceilingRowIndex = 0;
        
        while (globalIndex < items.length) {
          for (let j = 0; j < 2 && globalIndex < items.length; j++, globalIndex++) {
            const currentZ = rowIndex * rowSpacing + zOffset;
            this.addBox(items[globalIndex], leftX, 6 + j * (maxDimension + 2), currentZ, maxDimension, Math.PI / 2, false);
            lastZ = Math.max(lastZ, currentZ);
          }
          for (let j = 0; j < 2 && globalIndex < items.length; j++, globalIndex++) {
            const currentZ = rowIndex * rowSpacing + zOffset;
            this.addBox(items[globalIndex], rightX, 6 + j * (maxDimension + 2), currentZ, maxDimension, -Math.PI / 2, false);
            lastZ = Math.max(lastZ, currentZ);
          }
          rowIndex++;
          for (let j = 0; j < 2 && globalIndex < items.length; j++, globalIndex++) {
            const z = ceilingRowIndex * ceilingZSpacing + zOffset;
            this.addBox(items[globalIndex], ceilingX[j % 2], ceilingYOffset, z, maxDimension, -Math.PI / 2, true);
            lastZ = Math.max(lastZ, z);
          }
          ceilingRowIndex++;
        }
        
        this.createRoom();
      })
      .catch(err => {
        console.error('Gallery load failed:', err);
        LoadingManager.forceComplete();
      });
  },
  
  addBox(item, x, y, z, maxDim, rotationY = 0, isCeiling = false) {
    const loader = new THREE.TextureLoader();
    const videoSrc = item.thumbnail || item.src;
    
    if (!videoSrc) {
      console.error('Item has no src or thumbnail:', item);
      LoadingManager.increment();
      return;
    }
    
    const hasVideoThumbnail = videoSrc && (
      videoSrc.toLowerCase().endsWith('.mp4') || 
      videoSrc.toLowerCase().endsWith('.webm') || 
      videoSrc.toLowerCase().endsWith('.ogv')
    );
    
    const isGif = videoSrc && videoSrc.toLowerCase().endsWith('.gif');
    
    if (hasVideoThumbnail) {
      const video = document.createElement('video');
      video.src = videoSrc;
      video.loop = true;
      video.muted = true;
      video.playsInline = true;
      video.crossOrigin = 'anonymous';
      video.preload = 'auto';
      
      const handleMetadata = () => {
        const aspect = video.videoWidth / video.videoHeight;
        let boxWidth, boxHeight;
        if (aspect >= 1) {
          boxWidth = maxDim;
          boxHeight = maxDim / aspect;
        } else {
          boxHeight = maxDim;
          boxWidth = maxDim * aspect;
        }
        
        const texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.format = THREE.RGBFormat;
        texture.generateMipmaps = false;
        
        const geometry = new THREE.PlaneGeometry(boxWidth, boxHeight);
        const material = new THREE.MeshStandardMaterial({ 
          map: texture, 
          side: THREE.DoubleSide,
          emissive: 0x222222,
          emissiveIntensity: 0.2,
          metalness: 0,
          roughness: 1
        });
        const box = new THREE.Mesh(geometry, material);
        
        if (isCeiling) {
          box.position.set(x, y, z);
          box.rotation.x = -Math.PI / 2;
        } else {
          box.position.set(x, y + boxHeight / 2, z);
          box.rotation.y = rotationY;
        }
        
        if (!CONFIG.IS_MOBILE) {
          box.castShadow = true;
          box.receiveShadow = true;
        }
        
        box.userData.galleryItem = item;
        if (item.vimeoUrl) {
          const vimeoMatch = item.vimeoUrl.match(/vimeo\.com\/(\d+)/);
          if (vimeoMatch) {
            const videoId = vimeoMatch[1];
            box.userData.popup = `<div class="popup-images-scroll"><iframe src="https://player.vimeo.com/video/${videoId}?autoplay=0&loop=0&title=0&byline=0&portrait=0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe></div>`;
          } else {
            box.userData.popup = `<div class="popup-images-scroll"><video src="${videoSrc}" controls autoplay loop></video></div>`;
          }
        } else {
          box.userData.popup = `<div class="popup-images-scroll"><video src="${videoSrc}" controls autoplay loop></video></div>`;
        }
        box.userData.video = video;
        
        this.scene.add(box);
        this.boxes.push(box);
        this.videos.push(video);
        
        video.play().catch(e => {
          setTimeout(() => video.play().catch(() => {}), 100);
        });
        
        LoadingManager.increment();
      };
      
      const handleError = (e) => {
        console.error('Video thumbnail load error:', videoSrc, e);
        LoadingManager.increment();
      };
      
      video.addEventListener('loadedmetadata', handleMetadata);
      video.addEventListener('error', handleError);
      video.load();
      return;
    }
    
    if (isGif) {
      const canvas = document.createElement('canvas');
      const maxCanvasSize = 512;
      canvas.width = maxCanvasSize;
      canvas.height = maxCanvasSize;
      
      const loadTimeout = setTimeout(() => {
        console.warn('GIF load timeout:', item.src);
        LoadingManager.increment();
      }, 8000);
      
      try {
        gifler(item.src).get((anim) => {
          clearTimeout(loadTimeout);
          
          const scale = Math.min(maxCanvasSize / anim.width, maxCanvasSize / anim.height, 1);
          canvas.width = Math.floor(anim.width * scale);
          canvas.height = Math.floor(anim.height * scale);
          
          const ctx = canvas.getContext('2d', { 
            alpha: false,
            willReadFrequently: false,
            desynchronized: true 
          });
          
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = false;
          
          const aspect = anim.width / anim.height;
          let boxWidth, boxHeight;
          if (aspect >= 1) {
            boxWidth = maxDim;
            boxHeight = maxDim / aspect;
          } else {
            boxHeight = maxDim;
            boxWidth = maxDim * aspect;
          }
          
          const geometry = new THREE.PlaneGeometry(boxWidth, boxHeight);
          const material = new THREE.MeshStandardMaterial({ 
            map: texture, 
            side: THREE.DoubleSide,
            metalness: 0,
            roughness: 1
          });
          const box = new THREE.Mesh(geometry, material);
          
          if (isCeiling) {
            box.position.set(x, y, z);
            box.rotation.x = -Math.PI / 2;
          } else {
            box.position.set(x, y + boxHeight / 2, z);
            box.rotation.y = rotationY;
          }
          
          if (!CONFIG.IS_MOBILE) {
            box.castShadow = true;
            box.receiveShadow = true;
          }
          
          box.userData.galleryItem = item;
          box.userData.popup = `<div class="popup-images-scroll"><img src="${videoSrc}"></div>`;
          this.scene.add(box);
          this.boxes.push(box);
          
          this.gifAnimations.push(anim);
          
          let animationRunning = true;
          let lastUpdate = 0;
          const fps = 30;
          const frameDelay = 1000 / fps;
          
          const updateTexture = (timestamp) => {
            if (!animationRunning) return;
            
            if (timestamp - lastUpdate >= frameDelay) {
              if (!GalleryApp.menuOpen) {
                try {
                  anim.animateInCanvas(canvas);
                  texture.needsUpdate = true;
                } catch (e) {
                  console.error('GIF animation error:', e);
                  animationRunning = false;
                }
              }
              lastUpdate = timestamp;
            }
            
            requestAnimationFrame(updateTexture);
          };
          
          requestAnimationFrame(updateTexture);
          
          anim.stop = () => { animationRunning = false; };
          anim.play = () => { animationRunning = true; lastUpdate = 0; };
          
          LoadingManager.increment();
        }).catch((err) => {
          clearTimeout(loadTimeout);
          console.error('GIF error:', item.src, err);
          LoadingManager.increment();
        });
      } catch (e) {
        clearTimeout(loadTimeout);
        console.error('GIF exception:', item.src, e);
        LoadingManager.increment();
      }
    } else {
      const loadTimeout = setTimeout(() => {
        console.warn('Image load timeout:', item.src);
        LoadingManager.increment();
      }, 5000);
      
      loader.load(
        videoSrc,
        texture => {
          clearTimeout(loadTimeout);
          const aspect = texture.image.width / texture.image.height;
          let boxWidth, boxHeight;
          if (aspect >= 1) {
            boxWidth = maxDim;
            boxHeight = maxDim / aspect;
          } else {
            boxHeight = maxDim;
            boxWidth = maxDim * aspect;
          }
          
          const geometry = new THREE.PlaneGeometry(boxWidth, boxHeight);
          const material = new THREE.MeshStandardMaterial({ 
            map: texture, 
            side: THREE.DoubleSide,
            metalness: 0,
            roughness: 1
          });
          const box = new THREE.Mesh(geometry, material);
          
          if (isCeiling) {
            box.position.set(x, y, z);
            box.rotation.x = -Math.PI / 2;
              box.scale.x = -1; 
          } else {
            box.position.set(x, y + boxHeight / 2, z);
            box.rotation.y = rotationY;
          }
          
          if (!CONFIG.IS_MOBILE) {
            box.castShadow = true;
            box.receiveShadow = true;
          }
          
          box.userData.galleryItem = item;
          box.userData.popup = `<div class="popup-images-scroll"><img src="${videoSrc}"></div>`;
          this.scene.add(box);
          this.boxes.push(box);
          
          LoadingManager.increment();
        },
        undefined,
        (err) => {
          clearTimeout(loadTimeout);
          console.error('Image load error:', videoSrc, err);
          LoadingManager.increment();
        }
      );
    }
  },
  
  pauseAllAnimations() {
    this.gifAnimations.forEach(anim => {
      if (anim.stop) anim.stop();
    });
    this.videos.forEach(video => {
      video.pause();
    });
  },
  
  resumeAllAnimations() {
    this.gifAnimations.forEach(anim => {
      if (anim.play) anim.play();
    });
    this.videos.forEach(video => {
      video.play().catch(e => console.warn('Video resume failed:', e));
    });
  }
};

const PhysicsManager = {
  velocity: new THREE.Vector3(),
  direction: new THREE.Vector3(),
  canJump: false,
  raycaster: new THREE.Raycaster(),
  
  update(delta) {
    const yaw = SceneManager.yaw;
    
    yaw.position.x = Math.max(-95, Math.min(85, yaw.position.x));
    const roomEndZ = Math.max(...SceneManager.objects.map(o => o.position.z)) - 5;
    yaw.position.z = Math.max(5, Math.min(roomEndZ, yaw.position.z));
    
    this.raycaster.ray.origin.copy(yaw.position);
    this.raycaster.ray.origin.y += 1;
    this.raycaster.ray.direction.set(0, -1, 0);
    const hits = this.raycaster.intersectObjects(SceneManager.objects, false);
    const onGround = hits.length > 0 && hits[0].distance < 2;
    
    this.velocity.x -= this.velocity.x * 8 * delta;
    this.velocity.z -= this.velocity.z * 8 * delta;
    this.velocity.y -= 5 * 200 * delta;
    
    const input = InputManager.getMovementInput();
    this.direction.set(input.x, 0, input.z).normalize();
    
    const moveSpeed = CONFIG.IS_MOBILE ? CONFIG.MOBILE_MOVEMENT_SPEED : CONFIG.MOVEMENT_SPEED;
    
    if (this.direction.z) this.velocity.z -= this.direction.z * moveSpeed * delta;
    if (this.direction.x) this.velocity.x += this.direction.x * moveSpeed * delta;
    
    if (!onGround) {
      const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);
      const maxAir = 300, airAccel = 400;
      if (this.direction.x && speed < maxAir) this.velocity.x += this.direction.x * airAccel * delta;
      if (this.direction.z && speed < maxAir) this.velocity.z -= this.direction.z * airAccel * delta;
    }
    
    if (onGround) {
      this.velocity.y = Math.max(0, this.velocity.y);
      this.canJump = true;
    }
    
    if (InputManager.keys.Space && this.canJump) {
      this.velocity.y += CONFIG.JUMP_FORCE;
      this.canJump = false;
    }
    
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yaw.quaternion).setY(0).normalize();
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(yaw.quaternion).setY(0).normalize();
    yaw.position.addScaledVector(forward, this.velocity.z * delta);
    yaw.position.addScaledVector(right, this.velocity.x * delta);
    yaw.position.y += this.velocity.y * delta;
    
    if (yaw.position.y < 20) {
      this.velocity.y = 0;
      yaw.position.y = 20;
      this.canJump = true;
    }
  }
};

const InteractionManager = {
  raycaster: new THREE.Raycaster(),
  reticle: null,
  hoveredBox: null,
  
  init() {
    this.reticle = document.getElementById('reticle');
    
    if (!CONFIG.IS_MOBILE) {
      document.addEventListener('mousemove', (e) => {
        if (InputManager.pointerLocked && !GalleryApp.popupVisible && !GalleryApp.menuOpen) {
          SceneManager.yaw.rotation.y -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
          SceneManager.pitch.rotation.x = Math.max(
            -Math.PI/2, 
            Math.min(Math.PI/2, SceneManager.pitch.rotation.x - e.movementY * CONFIG.MOUSE_SENSITIVITY)
          );
        }
      });
      
      document.addEventListener('click', (e) => {
        if (CONFIG.IS_MOBILE) return;
        
        ShotgunGif.play();
        
        if (GalleryApp.popupVisible) return;
        if (!InputManager.pointerLocked || GalleryApp.menuOpen) return;
        
        if (this.hoveredBox) {
          const cameraPos = new THREE.Vector3();
          SceneManager.camera.getWorldPosition(cameraPos);
          const dist = cameraPos.distanceTo(this.hoveredBox.position);
          
          if (dist <= CONFIG.CLICK_DISTANCE) {
            GalleryApp.showPopup(this.hoveredBox);
          }
        }
      });
    }
  },
  
  update() {
    if (CONFIG.IS_MOBILE && (InputManager.mobileLookDelta.x !== 0 || InputManager.mobileLookDelta.y !== 0)) {
      SceneManager.yaw.rotation.y -= InputManager.mobileLookDelta.x * CONFIG.MOBILE_LOOK_SENSITIVITY;
      SceneManager.pitch.rotation.x = Math.max(
        -Math.PI/2,
        Math.min(Math.PI/2, SceneManager.pitch.rotation.x - InputManager.mobileLookDelta.y * CONFIG.MOBILE_LOOK_SENSITIVITY)
      );
    }
    
    if ((!CONFIG.IS_MOBILE && !InputManager.pointerLocked) || GalleryApp.popupVisible || GalleryApp.menuOpen) {
      this.reticle.classList.remove('hover');
      this.hoveredBox = null;
      return;
    }
    
    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), SceneManager.camera);
    const intersects = this.raycaster.intersectObjects(SceneManager.boxes);
    
    if (intersects.length > 0) {
      const obj = intersects[0].object;
      const cameraPos = new THREE.Vector3();
      SceneManager.camera.getWorldPosition(cameraPos);
      const dist = cameraPos.distanceTo(obj.position);
      
      if (dist <= CONFIG.HOVER_DISTANCE) {
        this.reticle.classList.add('hover');
        this.hoveredBox = obj;
      } else {
        this.reticle.classList.remove('hover');
        this.hoveredBox = null;
      }
    } else {
      this.reticle.classList.remove('hover');
      this.hoveredBox = null;
    }
  }
};

const GalleryApp = {
  menuOpen: false,
  popupVisible: false,
  popupJustClosed: false,
  animationId: null,
  prevTime: performance.now(),
  
  init() {
    LoadingManager.init();
    InputManager.init();
    SceneManager.init();
    InteractionManager.init();
    ShotgunGif.init();
    
    SceneManager.loadGallery();
    
    document.querySelectorAll('.menu-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const url = e.target.dataset.url;
        if (url) window.location.href = url;
      });
    });
    
    this.animate();
  },
  
  handleMenuClick(event) {
    if (event.target.id === 'top-menu') {
      this.closeMenu();
    }
  },
  
  toggleMenu() {
    this.menuOpen ? this.closeMenu() : this.openMenu();
  },
  
  openMenu() {
    if (this.menuOpen) return;
    this.menuOpen = true;
    const menu = document.getElementById('top-menu');
    menu.style.display = 'flex';
    SceneManager.pauseAllAnimations();
    
    if (CONFIG.IS_MOBILE) {
      const gifImg = document.getElementById('menu-random-gif');
      const randomGif = CONFIG.gifUrls[Math.floor(Math.random() * CONFIG.gifUrls.length)];
      gifImg.src = randomGif;
      gifImg.style.display = 'block';
      
      const closeBtn = document.getElementById('mobile-menu-close');
      closeBtn.style.display = 'flex';
    }
    
    if (!CONFIG.IS_MOBILE && document.pointerLockElement) {
      document.exitPointerLock();
    }
  },
  
  closeMenu() {
    if (!this.menuOpen) return;
    this.menuOpen = false;
    const menu = document.getElementById('top-menu');
    menu.style.display = 'none';
    SceneManager.resumeAllAnimations();
    
    if (CONFIG.IS_MOBILE) {
      const gifImg = document.getElementById('menu-random-gif');
      gifImg.style.display = 'none';
      gifImg.src = '';
      
      const closeBtn = document.getElementById('mobile-menu-close');
      closeBtn.style.display = 'none';
    }
    
    if (!CONFIG.IS_MOBILE) {
      document.body.requestPointerLock();
    }
  },
  
 showPopup(box) {
  const popup = document.getElementById('popup');
  const popupContent = document.getElementById('popup-content');
  
  if (CONFIG.IS_MOBILE && box.userData.isMobileCategory) {
    const cat = box.userData.categoryData;
    
    fetch('assets/gallery.json')
      .then(res => res.json())
      .then(allItems => {
        const items = allItems.filter(item => item.category === cat.category);
        
        let html = '<div class="popup-images-scroll">';
        
        items.forEach(item => {
          const src = item.thumbnail || item.src;
          
          if (src && (src.toLowerCase().endsWith('.mp4') || src.toLowerCase().endsWith('.webm'))) {
            if (item.vimeoUrl) {
              const vimeoMatch = item.vimeoUrl.match(/vimeo\.com\/(\d+)/);
              if (vimeoMatch) {
                const videoId = vimeoMatch[1];
                html += `<iframe src="https://player.vimeo.com/video/${videoId}?autoplay=0&loop=0&title=0&byline=0&portrait=0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen style="width:100%;aspect-ratio:16/9;display:block;margin-bottom:10px;border:none;"></iframe>`;
              }
            } else {
              html += `<video src="${src}" controls playsinline style="width:100%;height:auto;display:block;margin-bottom:10px;"></video>`;
            }
          } else if (src) {
            html += `<img src="${src}" style="width:100%;height:auto;display:block;margin-bottom:10px;">`;
          }
        });
        
        html += '</div>';
        popupContent.innerHTML = html;
      })
      .catch(err => {
        console.error('Failed to load gallery JSON:', err);
        popupContent.innerHTML = '<div class="popup-images-scroll"><p style="color:#fff;text-align:center;padding:40px;">Failed to load content</p></div>';
      });
  } else {
    popupContent.innerHTML = box.userData.popup || '';
  }
  
  popup.style.display = 'flex';
  this.popupVisible = true;
  
  if (!CONFIG.IS_MOBILE && document.pointerLockElement) {
    document.exitPointerLock();
  }
},
  
hidePopup() {
  const popup = document.getElementById('popup');
  const popupContent = document.getElementById('popup-content');
  
  // Stop all videos and iframes in the popup
  const videos = popupContent.querySelectorAll('video');
  videos.forEach(video => {
    video.pause();
    video.currentTime = 0;
    video.removeAttribute('src');
    video.load();
  });
  
  const iframes = popupContent.querySelectorAll('iframe');
  iframes.forEach(iframe => {
    iframe.src = 'about:blank';
    setTimeout(() => iframe.src = '', 0);
  });
  
  popup.style.display = 'none';
  this.popupVisible = false;
  this.popupJustClosed = true;
  
  setTimeout(() => {
    this.popupJustClosed = false;
    if (!CONFIG.IS_MOBILE && !this.menuOpen) {
      document.body.requestPointerLock();
    }
  }, 150);
},
  
  animate() {
    this.animationId = requestAnimationFrame(() => this.animate());
    
    const time = performance.now();
    const delta = (time - this.prevTime) / 1000;
    this.prevTime = time;
    
    if (!this.menuOpen) {
      PhysicsManager.update(delta);
      InteractionManager.update();
    }
    
    SceneManager.renderer.render(SceneManager.scene, SceneManager.camera);
  }
};

GalleryApp.init();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1" />
  <title>Portfolio</title>
  <style>
    @font-face {
      font-family: 'Monospace821Bold';
      src: url('assets/fonts/MONOSPACE821BOLDBT.TTF') format('truetype');
      font-weight: bold;
    }
    @font-face {
      font-family: 'Monospace821';
      src: url('assets/fonts/MONOSPACE821BT.TTF') format('truetype');
      font-weight: normal;
    }
    @import url('https://fonts.googleapis.com/css?family=Oswald:wght@400;600&display=swap');

    body { 
      margin: 0; 
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Reticle */
    #reticle {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid #fff;
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      transition: all 0.2s ease;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }

    #reticle.hover {
      border-color: #22ff00;
      box-shadow: 0 0 20px rgba(34,255,0,0.8);
      transform: scale(1.3);
    }

    /* Menu */
    #top-menu {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: invert(100%) blur(5px);
      z-index: 9999;
      padding: 40px;
      box-sizing: border-box;
      overflow-y: auto;
      align-items: flex-start;
      justify-content: flex-start;
      flex-direction: column;
    }

    #menu-logo {
      width: 150px;    
      height: auto;
      margin-bottom: 60px;
      cursor: pointer;
      transition: transform 0.3s ease, filter 0.3s ease;
      align-self: flex-start;
    }

    #menu-logo img {
      width: 100%;
      height: auto;
    }

    #menu-pages {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      gap: 20px;
    }

    .menu-btn {
      font-family: 'monospace821';
      font-weight: 900;
      font-size: 8em;
      background: none;
      color: #ffffff;
      cursor: pointer;
      border: none;
      text-align: left;
      text-decoration: underline;
      padding: 10px 0;
      transition: color 0.2s;
    }

    .menu-btn:hover {
      color: rgb(34, 255, 0);
    }

    #menu-info {
      margin-top: 40px;
      font-family: 'monospace821';
      color: #fff;
      font-size: 1.5em;
    }

    /* Popup */
    #popup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      justify-content: center;
      align-items: center;
      z-index: 10001;
    }

    #popup-content {
      width: 80%;
      height: 80%;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #popup-close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: none;
      color: #fff;
      border: none;
      font-size: 48px;
      font-weight: bold;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10002;
      font-family: Arial, sans-serif;
      line-height: 1;
    }

    @media (max-width: 768px) {
      #popup-close-btn {
        display: flex;
      }
    }

    .popup-images-scroll {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .popup-images-scroll img,
    .popup-images-scroll video {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      display: block;
    }

    .popup-images-scroll video {
      width: 100%;
      height: 100vh;
      object-fit: cover;
    }

    /* Click prompt */
    #click-prompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Monospace821Bold', monospace;
      font-size: 2em;
      color: #fff;
      background-color: #000;
      text-align: center;
      z-index: 500;
      pointer-events: none;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      padding: 20px;
    }

    /* Mobile Controls */
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 200px;
      z-index: 1000;
      pointer-events: none;
    }

    .mobile-joystick {
      position: absolute;
      width: 120px;
      height: 120px;
      bottom: 40px;
      pointer-events: auto;
    }

    #movement-joystick {
      left: 40px;
    }

    .joystick-base {
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      border: 3px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      position: relative;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    .joystick-stick {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.7);
      border: 2px solid #fff;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: none;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      clip-path: polygon(
        0px calc(100% - 20px),
        4px calc(100% - 20px),
        4px calc(100% - 12px),
        8px calc(100% - 12px),
        8px calc(100% - 8px),
        12px calc(100% - 8px),
        12px calc(100% - 4px),
        20px calc(100% - 4px),
        20px 100%,
        calc(100% - 20px) 100%,
        calc(100% - 20px) calc(100% - 4px),
        calc(100% - 12px) calc(100% - 4px),
        calc(100% - 12px) calc(100% - 8px),
        calc(100% - 8px) calc(100% - 8px),
        calc(100% - 8px) calc(100% - 12px),
        calc(100% - 4px) calc(100% - 12px),
        calc(100% - 4px) calc(100% - 20px),
        100% calc(100% - 20px),
        100% 20px,
        calc(100% - 4px) 20px,
        calc(100% - 4px) 12px,
        calc(100% - 8px) 12px,
        calc(100% - 8px) 8px,
        calc(100% - 12px) 8px,
        calc(100% - 12px) 4px,
        calc(100% - 20px) 4px,
        calc(100% - 20px) 0px,
        20px 0px,
        20px 4px,
        12px 4px,
        12px 8px,
        8px 8px,
        8px 12px,
        4px 12px,
        4px 20px,
        0px 20px
      );
    }

    /* Shotgun GIF */
    #shotgun-gif {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 800px;
      height: auto;
      max-height: 1500px;
      z-index: 999;
      pointer-events: none;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    #mobile-menu-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1001;
      font-family: 'Monospace821Bold', monospace;
      font-size: 2em;
      color: #fff;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #fff;
      padding: 8px 16px;
      cursor: pointer;
      display: none;
      pointer-events: auto;
      width: 50px;
      height: 50px;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }

    @media (max-width: 768px) {
      #mobile-controls {
        display: block;
      }
      
      #mobile-menu-btn {
        display: flex;
      }
      
      #click-prompt {
        display: none !important;
      }
      
      #reticle {
        display: block;
      }
      
      .menu-btn {
        font-size: 12vw;
        line-height: 1.1;
        width: 100%;
      }
      
      #menu-logo {
        width: 120px;
        margin-bottom: 40px;
      }
      
      #top-menu {
        padding: 40px;
        padding-top: 60px;
        align-items: flex-start;
        justify-content: flex-start;
      }
      
      #menu-pages {
        align-items: flex-start;
        width: 100%;
        gap: 10px;
      }

      #menu-info {
        display: none;
      }
      
      #menu-random-gif {
        display: block;
        margin-top: 40px;
        width: 80%;
        max-width: 400px;
        height: auto;
        border: 3px solid #fff;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
      }
    }

    @media (min-width: 769px) {
      #menu-logo {
        position: absolute;
        top: 40px;
        right: 150px;
        width: 200px;
        margin-bottom: 0;
      }
      
      #menu-pages {
        align-items: flex-start;
      }
      
      .menu-btn {
        font-size: 15em;
        text-align: left;
      }
      
      #top-menu {
        align-items: flex-start;
        justify-content: flex-start;
      }
      
      #menu-random-gif {
        display: none;
      }
    }

    /* Hidden video elements for texture */
    .hidden-video {
      position: absolute;
      left: -9999px;
      top: -9999px;
      visibility: hidden;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/gifler@0.1.0/gifler.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="reticle"></div>
<div id="click-prompt">|| CLICK_TO_START || ESC=MENU</div>

<div id="top-menu" onclick="GalleryApp.handleMenuClick(event)">
  <div id="menu-logo">
    <a href="index.html"><img src="assets/haumlogofinal.svg" alt="Logo"></a>
  </div>
  <div id="menu-pages">
    <button class="menu-btn" data-url="home.html">HOME</button>
    <button class="menu-btn" data-url="about.html">ABOUT</button>
    <button class="menu-btn" data-url="gallery.html">GALLERY</button>
    <div id="menu-info">// WASD=MOVE // MOUSE=LOOK_AROUND // ESC=MENU // CLICK=SELECT //</div>
  </div>
  <img id="menu-random-gif" src="" alt="Random GIF" style="display: none;">
</div>

<div id="popup">
  <button id="popup-close-btn" onclick="GalleryApp.hidePopup()">×</button>
  <div id="popup-content"></div>
</div>

<button id="mobile-menu-btn">+</button>

<img id="shotgun-gif" src="assets/POVSHOTGUN_static.png" alt="Shotgun">

<div id="mobile-controls">
  <div id="movement-joystick" class="mobile-joystick">
    <div class="joystick-base">
      <div class="joystick-stick"></div>
    </div>
  </div>
</div>

<div id="hidden-videos-container"></div>

<script>
// Detect mobile
const IS_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

// ===== SHOTGUN GIF MANAGER =====
const ShotgunGif = {
  imgElement: null,
  isPlaying: false,
  staticFrameUrl: 'assets/POVSHOTGUN_static.png',
  animatedUrl: 'assets/POVSHOTGUN.gif',
  
  init() {
    this.imgElement = document.getElementById('shotgun-gif');
    this.imgElement.src = this.staticFrameUrl;
    console.log('Shotgun GIF initialized with static frame');
  },
  
  play() {
    if (this.isPlaying || !this.imgElement) {
      console.log('Shotgun already playing or not loaded');
      return;
    }
    
    console.log('Playing shotgun animation!');
    this.isPlaying = true;
    
    this.imgElement.src = this.animatedUrl + '?' + Math.random();
    
    setTimeout(() => {
      this.imgElement.src = this.staticFrameUrl;
      this.isPlaying = false;
      console.log('Animation complete, back to static');
    }, 1500);
  }
};

// ===== CONFIG MODULE =====
const CONFIG = {
  IS_MOBILE: IS_MOBILE,
  HOVER_DISTANCE: 160,
  CLICK_DISTANCE: 200,
  MOVEMENT_SPEED: 150,
  MOBILE_MOVEMENT_SPEED: 300,
  JUMP_FORCE: 350,
  MOUSE_SENSITIVITY: 0.002,
  MOBILE_LOOK_SENSITIVITY: 0.006,
  
  // Mobile optimizations
  MOBILE_MAX_TEXTURE_SIZE: 512,
  MOBILE_REDUCE_QUALITY: IS_MOBILE,
  MOBILE_DISABLE_SHADOWS: IS_MOBILE,
  MOBILE_LIMIT_DRAW_DISTANCE: IS_MOBILE ? 400 : 700,
  
  gifUrls: [
    'assets/arach.gif', 'assets/baron.gif', 'assets/chomphead.gif', 'assets/dancingdino.gif',
    'assets/dragonmouth.gif', 'assets/elemental.gif', 'assets/greendragon.gif', 'assets/jackhammer.gif',
    'assets/legorun.gif', 'assets/orangedino.gif', 'assets/pinkydemon.gif', 'assets/shotgunblast.gif',
    'assets/skullfire.gif', 'assets/whitedragon.gif', 'assets/yellowdragon.gif'
  ]
};

// ===== INPUT MANAGER MODULE =====
const InputManager = {
  keys: {},
  pointerLocked: false,
  mobileMovement: { x: 0, z: 0 },
  mobileLookDelta: { x: 0, y: 0 },
  activeTouches: new Map(),
  
  init() {
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Escape') {
        e.preventDefault();
        GalleryApp.toggleMenu();
        return;
      }
      this.keys[e.code] = true;
    });
    
    document.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
    });
    
    if (!CONFIG.IS_MOBILE) {
      document.addEventListener('pointerlockchange', () => {
        const wasLocked = this.pointerLocked;
        this.pointerLocked = document.pointerLockElement === document.body;
        
        if (this.pointerLocked) {
          document.getElementById('click-prompt').style.display = 'none';
        }
        
        if (wasLocked && !this.pointerLocked && !GalleryApp.menuOpen && !GalleryApp.popupVisible) {
          GalleryApp.openMenu();
        }
      });
      
      document.addEventListener('click', () => {
        if (!this.pointerLocked && !GalleryApp.popupVisible && !GalleryApp.menuOpen) {
          document.body.requestPointerLock();
        }
      });
    } else {
      this.initMobileControls();
      document.getElementById('click-prompt').style.display = 'none';
    }
  },
  
  initMobileControls() {
    this.initJoystick('movement-joystick', (x, y) => {
      this.mobileMovement.x = x;
      this.mobileMovement.z = y;
    });
    
    // Multi-touch support for simultaneous joystick and camera control
    document.addEventListener('touchstart', (e) => {
      Array.from(e.changedTouches).forEach(touch => {
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        
        const isOnJoystick = target && target.closest('#movement-joystick');
        const isOnUI = target && (
          target.closest('#mobile-menu-btn') || 
          target.closest('#popup') ||
          target.closest('#top-menu')
        );
        
        this.activeTouches.set(touch.identifier, {
          startX: touch.clientX,
          startY: touch.clientY,
          lastX: touch.clientX,
          lastY: touch.clientY,
          isJoystick: isOnJoystick,
          isUI: isOnUI,
          isCameraControl: !isOnJoystick && !isOnUI
        });
      });
    });
    
    document.addEventListener('touchmove', (e) => {
      if (GalleryApp.popupVisible || GalleryApp.menuOpen) return;
      
      Array.from(e.changedTouches).forEach(touch => {
        const touchData = this.activeTouches.get(touch.identifier);
        if (!touchData) return;
        
        if (touchData.isCameraControl) {
          const deltaX = touch.clientX - touchData.lastX;
          const deltaY = touch.clientY - touchData.lastY;
          
          this.mobileLookDelta.x = deltaX;
          this.mobileLookDelta.y = deltaY;
          
          touchData.lastX = touch.clientX;
          touchData.lastY = touch.clientY;
        }
      });
    });
    
    document.addEventListener('touchend', (e) => {
      Array.from(e.changedTouches).forEach(touch => {
        const touchData = this.activeTouches.get(touch.identifier);
        
        if (touchData && touchData.isCameraControl) {
          const distMoved = Math.sqrt(
            Math.pow(touch.clientX - touchData.startX, 2) + 
            Math.pow(touch.clientY - touchData.startY, 2)
          );
          
          if (distMoved < 20) {
            ShotgunGif.play();
            
            if (!GalleryApp.popupVisible && !GalleryApp.menuOpen) {
              if (InteractionManager.hoveredBox) {
                const cameraPos = new THREE.Vector3();
                SceneManager.camera.getWorldPosition(cameraPos);
                const dist = cameraPos.distanceTo(InteractionManager.hoveredBox.position);
                
                if (dist <= CONFIG.CLICK_DISTANCE) {
                  GalleryApp.showPopup(InteractionManager.hoveredBox.userData.popup);
                }
              }
            }
          }
        }
        
        this.activeTouches.delete(touch.identifier);
      });
      
      const hasCameraTouch = Array.from(this.activeTouches.values()).some(t => t.isCameraControl);
      if (!hasCameraTouch) {
        this.mobileLookDelta.x = 0;
        this.mobileLookDelta.y = 0;
      }
    });
    
    document.addEventListener('touchcancel', (e) => {
      Array.from(e.changedTouches).forEach(touch => {
        this.activeTouches.delete(touch.identifier);
      });
      
      const hasCameraTouch = Array.from(this.activeTouches.values()).some(t => t.isCameraControl);
      if (!hasCameraTouch) {
        this.mobileLookDelta.x = 0;
        this.mobileLookDelta.y = 0;
      }
    });
    
    const menuBtn = document.getElementById('mobile-menu-btn');
    menuBtn.addEventListener('click', (e) => {
      e.preventDefault();
      GalleryApp.toggleMenu();
    });
  },
  
  initJoystick(id, callback) {
    const joystick = document.getElementById(id);
    const stick = joystick.querySelector('.joystick-stick');
    const base = joystick.querySelector('.joystick-base');
    
    let activeTouch = null;
    
    const handleStart = (e) => {
      e.preventDefault();
      if (e.touches && e.touches.length > 0) {
        activeTouch = e.touches[0].identifier;
      }
    };
    
    const handleMove = (e) => {
      if (activeTouch === null) return;
      e.preventDefault();
      
      let touch = null;
      if (e.touches) {
        for (let i = 0; i < e.touches.length; i++) {
          if (e.touches[i].identifier === activeTouch) {
            touch = e.touches[i];
            break;
          }
        }
      }
      if (!touch) return;
      
      const rect = base.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      let deltaX = touch.clientX - centerX;
      let deltaY = touch.clientY - centerY;
      
      const maxDistance = rect.width / 2 - 25;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      if (distance > maxDistance) {
        deltaX = (deltaX / distance) * maxDistance;
        deltaY = (deltaY / distance) * maxDistance;
      }
      
      stick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
      
      const normalizedX = deltaX / maxDistance;
      const normalizedY = deltaY / maxDistance;
      callback(normalizedX, normalizedY);
    };
    
    const handleEnd = (e) => {
      e.preventDefault();
      activeTouch = null;
      stick.style.transform = 'translate(-50%, -50%)';
      callback(0, 0);
    };
    
    joystick.addEventListener('touchstart', handleStart, { passive: false });
    joystick.addEventListener('touchmove', handleMove, { passive: false });
    joystick.addEventListener('touchend', handleEnd, { passive: false });
    joystick.addEventListener('touchcancel', handleEnd, { passive: false });
  },
  
  isKeyPressed(code) {
    return this.keys[code] || false;
  },
  
  getMovementInput() {
    if (CONFIG.IS_MOBILE) {
      return {
        x: this.mobileMovement.x,
        z: this.mobileMovement.z
      };
    } else {
      return {
        x: (this.isKeyPressed('KeyD') || this.isKeyPressed('ArrowRight') ? 1 : 0) - 
           (this.isKeyPressed('KeyA') || this.isKeyPressed('ArrowLeft') ? 1 : 0),
        z: (this.isKeyPressed('KeyS') || this.isKeyPressed('ArrowDown') ? 1 : 0) - 
           (this.isKeyPressed('KeyW') || this.isKeyPressed('ArrowUp') ? 1 : 0)
      };
    }
  }
};

// ===== SCENE MANAGER MODULE =====
const SceneManager = {
  scene: null,
  camera: null,
  renderer: null,
  yaw: null,
  pitch: null,
  objects: [],
  boxes: [],
  videoTextures: [],
  
  init() {
    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    this.pitch = new THREE.Object3D();
    this.pitch.add(this.camera);
    this.yaw = new THREE.Object3D();
    this.yaw.position.y = 20;
    this.yaw.add(this.pitch);
    this.yaw.rotation.y = 9.5;
    
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0xcc11cc);
    this.scene.fog = new THREE.Fog(0xff00ff, 0, CONFIG.MOBILE_LIMIT_DRAW_DISTANCE);
    this.scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.5));
    this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    
    // Only add directional light and shadows on desktop
    if (!CONFIG.MOBILE_DISABLE_SHADOWS) {
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(0, 300, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.left = -200;
      dirLight.shadow.camera.right = 200;
      dirLight.shadow.camera.top = 400;
      dirLight.shadow.camera.bottom = -400;
      dirLight.shadow.camera.near = 1;
      dirLight.shadow.camera.far = 500;
      this.scene.add(dirLight);
    }
    this.scene.add(this.yaw);
    
    this.extendRoom(500);
    
    this.renderer = new THREE.WebGLRenderer({ 
      antialias: !CONFIG.IS_MOBILE,
      powerPreference: CONFIG.IS_MOBILE ? "low-power" : "high-performance"
    });
    this.renderer.setPixelRatio(CONFIG.IS_MOBILE ? 1 : window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    
    if (!CONFIG.MOBILE_DISABLE_SHADOWS) {
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    }
    
    document.body.appendChild(this.renderer.domElement);
    
    window.addEventListener('resize', () => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    });
  },
  
  createCheckeredTexture(size = 1024, squares = 32) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');
    const s = size / squares;
    for (let y = 0; y < squares; y++) {
      for (let x = 0; x < squares; x++) {
        ctx.fillStyle = (x + y) % 2 ? '#1976D2' : '#FFD600';
        ctx.fillRect(x * s, y * s, s, s);
      }
    }
    return new THREE.CanvasTexture(canvas);
  },
  
  createDeformedGeometry(geometry, deformAmount = 10) {
    const pos = geometry.attributes.position;
    const vertex = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
      vertex.fromBufferAttribute(pos, i);
      vertex.x += (Math.random() - 0.5) * deformAmount;
      vertex.y += (Math.random() - 0.5) * deformAmount;
      vertex.z += (Math.random() - 0.5) * deformAmount;
      pos.setXYZ(i, vertex.x, vertex.y, vertex.z);
    }
    return geometry;
  },
  
  createWall(width, height, segments, position, rotation, deformAmount = 10) {
    const geometry = this.createDeformedGeometry(
      new THREE.PlaneGeometry(width, height, segments[0], segments[1]),
      deformAmount
    );
    const texture = this.createCheckeredTexture();
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(2, 2);
    
    const wall = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }));
    wall.position.set(...position);
    if (rotation) wall.rotation.set(...rotation);
    return wall;
  },
  
  extendRoom(newLength) {
    this.objects.forEach(obj => this.scene.remove(obj));
    this.objects.length = 0;
    
    const floorGeo = this.createDeformedGeometry(
      new THREE.PlaneGeometry(200, newLength, 20, Math.max(2, Math.ceil(newLength / 10))),
      2
    );
    floorGeo.rotateX(-Math.PI / 2);
    const tex = this.createCheckeredTexture();
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2, Math.max(1, newLength / 50));
    const floor = new THREE.Mesh(
      floorGeo,
      new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide })
    );
    floor.position.set(0, 4, newLength / 2);
    floor.receiveShadow = true;
    floor.userData.type = 'floorOrWall';
    this.scene.add(floor);
    this.objects.push(floor);
    
    const walls = [
      this.createWall(newLength, 200, [20, 40], [-100, -1, newLength / 2], [0, Math.PI/2, -0.15]),
      this.createWall(newLength, 200, [20, 40], [90, 4, newLength / 2], [0, Math.PI/2, 0.15]),
      this.createWall(200, 200, [20, 40], [0, 4, newLength], [0.15, 0, 0]),
      this.createWall(200, 200, [20, 40], [0, 4, 0], [-0.15, 0, 0])
    ];
    walls.forEach(w => {
      w.userData.type = 'floorOrWall';
      this.scene.add(w);
      this.objects.push(w);
    });
  },
  
  loadGallery() {
    fetch('assets/gallery.json')
      .then(res => res.json())
      .then(items => {
        const rowSpacing = 60, leftX = -70, rightX = 70, ceilingYOffset = 90;
        const ceilingX = [-30, 30], ceilingZSpacing = 50, maxDimension = 40, zOffset = 50;
        let globalIndex = 0, rowIndex = 0, ceilingRowIndex = 0, lastZ = 0;
        const loader = new THREE.TextureLoader();
        
        const addBox = (item, x, y, z, maxDim, rotationY = 0, isCeiling = false) => {
          const isVideo = item.type === 'video' || (item.src && (
            item.src.endsWith('.mp4') || 
            item.src.endsWith('.webm') || 
            item.src.endsWith('.ogv')
          ));
          
          const isGif = item.src && item.src.toLowerCase().endsWith('.gif');
          
          if (isVideo) {
            const video = document.createElement('video');
            video.src = item.src;
            video.loop = true;
            video.muted = true;
            video.playsInline = true;
            video.crossOrigin = 'anonymous';
            video.className = 'hidden-video';
            
            // Reduce video quality on mobile
            if (CONFIG.IS_MOBILE) {
              video.setAttribute('playsinline', '');
              video.setAttribute('webkit-playsinline', '');
            }
            
            document.getElementById('hidden-videos-container').appendChild(video);
            video.play().catch(err => console.log('Video autoplay prevented:', err));
            
            const videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            this.videoTextures.push(videoTexture);
            
            const aspect = video.videoWidth && video.videoHeight 
              ? video.videoWidth / video.videoHeight 
              : 16 / 9;
            
            let boxWidth, boxHeight;
            if (aspect >= 1) {
              boxWidth = maxDim;
              boxHeight = maxDim / aspect;
            } else {
              boxHeight = maxDim;
              boxWidth = maxDim * aspect;
            }
            
            const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, 0.5);
            const material = new THREE.MeshStandardMaterial({ map: videoTexture });
            const box = new THREE.Mesh(geometry, material);
            
            if (isCeiling) {
              box.position.set(x, y, z);
              box.rotation.x = -Math.PI / 2;
            } else {
              box.position.set(x, y + boxHeight / 2, z);
              box.rotation.y = rotationY;
            }
            
            box.userData.popup = `<div class="popup-images-scroll"><video src="${item.src}" controls autoplay loop style="width:100%; height:100vh; object-fit:cover;"></video></div>`;
            this.scene.add(box);
            this.boxes.push(box);
            
          } else if (isGif && !CONFIG.IS_MOBILE) {
            // Skip GIFs on mobile for performance
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              const aspect = img.width / img.height;
              let boxWidth, boxHeight;
              if (aspect >= 1) {
                boxWidth = maxDim;
                boxHeight = maxDim / aspect;
              } else {
                boxHeight = maxDim;
                boxWidth = maxDim * aspect;
              }
              
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              
              try {
                gifler(item.src).get((anim) => {
                  const texture = new THREE.CanvasTexture(canvas);
                  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, 0.5);
                  const material = new THREE.MeshStandardMaterial({ map: texture });
                  const box = new THREE.Mesh(geometry, material);
                  
                  if (isCeiling) {
                    box.position.set(x, y, z);
                    box.rotation.x = -Math.PI / 2;
                  } else {
                    box.position.set(x, y + boxHeight / 2, z);
                    box.rotation.y = rotationY;
                  }
                  
                  box.userData.popup = `<div class="popup-images-scroll"><img src="${item.src}" alt="${item.title || ''}" style="max-width:100%; height:auto; object-fit:contain;"></div>`;
                  this.scene.add(box);
                  this.boxes.push(box);
                  
                  anim.animateInCanvas(canvas);
                  function updateTexture() {
                    texture.needsUpdate = true;
                    requestAnimationFrame(updateTexture);
                  }
                  updateTexture();
                });
              } catch (e) {
                console.error('Error loading GIF:', e);
                loader.load(item.src, texture => {
                  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, 0.5);
                  const material = new THREE.MeshStandardMaterial({ map: texture });
                  const box = new THREE.Mesh(geometry, material);
                  if (isCeiling) {
                    box.position.set(x, y, z);
                    box.rotation.x = -Math.PI / 2;
                  } else {
                    box.position.set(x, y + boxHeight / 2, z);
                    box.rotation.y = rotationY;
                  }
                  box.userData.popup = `<div class="popup-images-scroll"><img src="${item.src}" alt="${item.title || ''}" style="max-width:100%; height:auto; object-fit:contain;"></div>`;
                  this.scene.add(box);
                  this.boxes.push(box);
                });
              }
            };
            img.src = item.src;
            
          } else {
            loader.load(item.src, texture => {
              // Reduce texture size on mobile
              if (CONFIG.IS_MOBILE && texture.image) {
                const canvas = document.createElement('canvas');
                const maxSize = CONFIG.MOBILE_MAX_TEXTURE_SIZE;
                const scale = Math.min(1, maxSize / Math.max(texture.image.width, texture.image.height));
                canvas.width = texture.image.width * scale;
                canvas.height = texture.image.height * scale;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(texture.image, 0, 0, canvas.width, canvas.height);
                texture = new THREE.CanvasTexture(canvas);
              }
              
              const aspect = texture.image.width / texture.image.height;
              let boxWidth, boxHeight;
              if (aspect >= 1) {
                boxWidth = maxDim;
                boxHeight = maxDim / aspect;
              } else {
                boxHeight = maxDim;
                boxWidth = maxDim * aspect;
              }
              const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, 0.5);
              const material = new THREE.MeshStandardMaterial({ map: texture });
              const box = new THREE.Mesh(geometry, material);
              if (isCeiling) {
                box.position.set(x, y, z);
                box.rotation.x = -Math.PI / 2;
              } else {
                box.position.set(x, y + boxHeight / 2, z);
                box.rotation.y = rotationY;
              }
              box.userData.popup = `<div class="popup-images-scroll"><img src="${item.src}" alt="${item.title || ''}" style="max-width:100%; height:auto; object-fit:contain;"></div>`;
              this.scene.add(box);
              this.boxes.push(box);
            });
          }
        };
        
        while (globalIndex < items.length) {
          for (let j = 0; j < 2 && globalIndex < items.length; j++, globalIndex++) {
            const item = items[globalIndex];
            const currentZ = rowIndex * rowSpacing + zOffset;
            lastZ = Math.max(lastZ, currentZ);
            addBox(item, leftX, 6 + j * (maxDimension + 2), currentZ, maxDimension, Math.PI / 2);
          }
          for (let j = 0; j < 2 && globalIndex < items.length; j++, globalIndex++) {
            const item = items[globalIndex];
            const currentZ = rowIndex * rowSpacing + zOffset;
            lastZ = Math.max(lastZ, currentZ);
            addBox(item, rightX, 6 + j * (maxDimension + 2), currentZ, maxDimension, Math.PI / 2);
          }
          rowIndex++;
          for (let j = 0; j < 2 && globalIndex < items.length; j++, globalIndex++) {
            const item = items[globalIndex];
            const z = ceilingRowIndex * ceilingZSpacing + zOffset;
            lastZ = Math.max(lastZ, z);
            addBox(item, ceilingX[j % 2], ceilingYOffset, z, maxDimension, -Math.PI / 2, true);
          }
          ceilingRowIndex++;
        }
        
        this.extendRoom(lastZ + 30);
      })
      .catch(err => console.error('Failed to load gallery JSON', err));
  }
};

// ===== PHYSICS MANAGER MODULE =====
const PhysicsManager = {
  velocity: new THREE.Vector3(),
  direction: new THREE.Vector3(),
  canJump: false,
  raycaster: new THREE.Raycaster(),
  
  update(delta) {
    const yaw = SceneManager.yaw;
    
    yaw.position.x = Math.max(-95, Math.min(85, yaw.position.x));
    const roomEndZ = Math.max(...SceneManager.objects.map(o => o.position.z)) - 5;
    yaw.position.z = Math.max(5, Math.min(roomEndZ, yaw.position.z));
    
    this.raycaster.ray.origin.copy(yaw.position);
    this.raycaster.ray.origin.y += 1;
    this.raycaster.ray.direction.set(0, -1, 0);
    const hits = this.raycaster.intersectObjects(SceneManager.objects, false);
    const onGround = hits.length > 0 && hits[0].distance < 2;
    
    this.velocity.x -= this.velocity.x * 8 * delta;
    this.velocity.z -= this.velocity.z * 8 * delta;
    this.velocity.y -= 5 * 200 * delta;
    
    const input = InputManager.getMovementInput();
    this.direction.set(input.x, 0, input.z).normalize();
    
    const moveSpeed = CONFIG.IS_MOBILE ? CONFIG.MOBILE_MOVEMENT_SPEED : CONFIG.MOVEMENT_SPEED;
    
    if (this.direction.z) this.velocity.z -= this.direction.z * moveSpeed * delta;
    if (this.direction.x) this.velocity.x += this.direction.x * moveSpeed * delta;
    
    if (!onGround) {
      const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);
      const maxAir = 300, airAccel = 400;
      if (this.direction.x && speed < maxAir) this.velocity.x += this.direction.x * airAccel * delta;
      if (this.direction.z && speed < maxAir) this.velocity.z -= this.direction.z * airAccel * delta;
    }
    
    if (onGround) {
      this.velocity.y = Math.max(0, this.velocity.y);
      this.canJump = true;
    }
    
    if (InputManager.isKeyPressed('Space') && this.canJump) {
      this.velocity.y += CONFIG.JUMP_FORCE;
      this.canJump = false;
    }
    
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yaw.quaternion).setY(0).normalize();
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(yaw.quaternion).setY(0).normalize();
    yaw.position.addScaledVector(forward, this.velocity.z * delta);
    yaw.position.addScaledVector(right, this.velocity.x * delta);
    yaw.position.y += this.velocity.y * delta;
    
    if (yaw.position.y < 20) {
      this.velocity.y = 0;
      yaw.position.y = 20;
      this.canJump = true;
    }
  }
};

// ===== INTERACTION MANAGER MODULE =====
const InteractionManager = {
  raycaster: new THREE.Raycaster(),
  reticle: null,
  hoveredBox: null,
  
  init() {
    this.reticle = document.getElementById('reticle');
    
    if (!CONFIG.IS_MOBILE) {
      document.addEventListener('mousemove', (e) => {
        if (InputManager.pointerLocked && !GalleryApp.popupVisible && !GalleryApp.menuOpen) {
          SceneManager.yaw.rotation.y -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
          SceneManager.pitch.rotation.x = Math.max(
            -Math.PI / 2,
            Math.min(Math.PI / 2, SceneManager.pitch.rotation.x - e.movementY * CONFIG.MOUSE_SENSITIVITY)
          );
        }
      });
      
      document.addEventListener('click', (e) => {
        ShotgunGif.play();
        
        if (GalleryApp.popupVisible) {
          GalleryApp.hidePopup();
          return;
        }
        
        if (!InputManager.pointerLocked || GalleryApp.menuOpen) return;
        
        if (this.hoveredBox) {
          const cameraPos = new THREE.Vector3();
          SceneManager.camera.getWorldPosition(cameraPos);
          const dist = cameraPos.distanceTo(this.hoveredBox.position);
          
          if (dist <= CONFIG.CLICK_DISTANCE) {
            GalleryApp.showPopup(this.hoveredBox.userData.popup);
          }
        }
      });
    }
  },
  
  update() {
    // Handle mobile look controls
    if (CONFIG.IS_MOBILE && (InputManager.mobileLookDelta.x !== 0 || InputManager.mobileLookDelta.y !== 0)) {
      SceneManager.yaw.rotation.y -= InputManager.mobileLookDelta.x * CONFIG.MOBILE_LOOK_SENSITIVITY;
      SceneManager.pitch.rotation.x = Math.max(
        -Math.PI/2,
        Math.min(Math.PI/2, SceneManager.pitch.rotation.x - InputManager.mobileLookDelta.y * CONFIG.MOBILE_LOOK_SENSITIVITY)
      );
    }
    
    if ((!CONFIG.IS_MOBILE && !InputManager.pointerLocked) || GalleryApp.popupVisible || GalleryApp.menuOpen) {
      this.reticle.classList.remove('hover');
      this.hoveredBox = null;
      return;
    }
    
    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), SceneManager.camera);
    const intersects = this.raycaster.intersectObjects(SceneManager.boxes);
    
    if (intersects.length > 0) {
      const obj = intersects[0].object;
      const cameraPos = new THREE.Vector3();
      SceneManager.camera.getWorldPosition(cameraPos);
      const dist = cameraPos.distanceTo(obj.position);
      
      if (dist <= CONFIG.HOVER_DISTANCE) {
        this.reticle.classList.add('hover');
        this.hoveredBox = obj;
      } else {
        this.reticle.classList.remove('hover');
        this.hoveredBox = null;
      }
    } else {
      this.reticle.classList.remove('hover');
      this.hoveredBox = null;
    }
  }
};

// ===== MAIN APP MODULE =====
const GalleryApp = {
  menuOpen: false,
  popupVisible: false,
  animationId: null,
  prevTime: performance.now(),
  
  init() {
    InputManager.init();
    SceneManager.init();
    InteractionManager.init();
    ShotgunGif.init();
    
    SceneManager.loadGallery();
    
    document.querySelectorAll('.menu-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const url = e.target.dataset.url;
        if (url) window.location.href = url;
      });
    });
    
    this.animate();
  },
  
  handleMenuClick(event) {
    if (event.target.id === 'top-menu') {
      this.closeMenu();
    }
  },
  
  toggleMenu() {
    if (this.menuOpen) {
      this.closeMenu();
    } else {
      this.openMenu();
    }
  },
  
  openMenu() {
    if (this.menuOpen) return;
    this.menuOpen = true;
    const menu = document.getElementById('top-menu');
    menu.style.display = 'flex';
    
    if (CONFIG.IS_MOBILE) {
      const gifImg = document.getElementById('menu-random-gif');
      const randomGif = CONFIG.gifUrls[Math.floor(Math.random() * CONFIG.gifUrls.length)];
      gifImg.src = randomGif;
      gifImg.style.display = 'block';
    }
    
    if (!CONFIG.IS_MOBILE && document.pointerLockElement) {
      document.exitPointerLock();
    }
  },
  
  closeMenu() {
    if (!this.menuOpen) return;
    this.menuOpen = false;
    const menu = document.getElementById('top-menu');
    menu.style.display = 'none';
    
    if (CONFIG.IS_MOBILE) {
      const gifImg = document.getElementById('menu-random-gif');
      gifImg.style.display = 'none';
      gifImg.src = '';
    }
    
    if (!CONFIG.IS_MOBILE) {
      document.body.requestPointerLock();
    }
  },
  
  showPopup(html) {
    const popup = document.getElementById('popup');
    const popupContent = document.getElementById('popup-content');
    popupContent.innerHTML = html;
    popup.style.display = 'flex';
    this.popupVisible = true;
    
    if (!CONFIG.IS_MOBILE && document.pointerLockElement) {
      document.exitPointerLock();
    }
  },
  
  hidePopup() {
    const popup = document.getElementById('popup');
    popup.style.display = 'none';
    this.popupVisible = false;
    
    if (!CONFIG.IS_MOBILE && !this.menuOpen) {
      document.body.requestPointerLock();
    }
  },
  
  animate() {
    this.animationId = requestAnimationFrame(() => this.animate());
    
    const time = performance.now();
    const delta = (time - this.prevTime) / 1000;
    this.prevTime = time;
    
    if (!this.menuOpen) {
      PhysicsManager.update(delta);
      InteractionManager.update();
    }
    
    SceneManager.renderer.render(SceneManager.scene, SceneManager.camera);
  }
};

GalleryApp.init();
</script>

</body>
</html>
